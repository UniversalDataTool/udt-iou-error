{"version":3,"sources":["node_modules/libtess/libtess.min.js","node_modules/polygon-tools/lib/vec.js","node_modules/polygon-tools/lib/polygon.js","node_modules/polygon-tools/lib/tesselator.js","node_modules/polygon-tools/lib/index.js","node_modules/polygon-offset/src/edge.js","node_modules/martinez-polygon-clipping/src/edge_type.js","node_modules/tinyqueue/index.js","node_modules/bintrees/lib/treebase.js","node_modules/bintrees/lib/rbtree.js","node_modules/bintrees/lib/bintree.js","node_modules/bintrees/index.js","node_modules/martinez-polygon-clipping/src/signed_area.js","node_modules/martinez-polygon-clipping/src/sweep_event.js","node_modules/martinez-polygon-clipping/src/compare_events.js","node_modules/martinez-polygon-clipping/src/equals.js","node_modules/martinez-polygon-clipping/src/compare_segments.js","node_modules/martinez-polygon-clipping/src/segment_intersection.js","node_modules/martinez-polygon-clipping/src/index.js","node_modules/martinez-polygon-clipping/index.js","node_modules/polygon-offset/src/utils.js","node_modules/polygon-offset/src/offset.js","index.js"],"names":["require","polygon","Offset","getPolygonFromUDTRegions","regions","classification","udtPolygons","map","r","regionType","type","points","length","x","centerX","width","y","centerY","height","filter","Boolean","polys","p","firstPolyIndex","findIndex","outputPoly","i","poly","union","flatMap","innerPoly","subtract","sumArea","polygons","area","reduce","acc","inflate","amount","offset","data","margin","getUnionAndIntersection","p1","p2","fullArea","fullAreaMinusP1","fullAreaMinusP2","fullAreaMinusP1P2","p1Area","p2Area","unionArea","intersectionArea","getIOU","ann1","ann2","classifications","borderMargin","totalUnionArea","totalIntersectionArea","Array","from","Set","s","p1Inflated","p2Inflated","infIntersection","module","exports"],"mappings":";AA6BA,aAAA,IAAA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,SAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EACA,SAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,SAAA,EAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAAA,GAAA,IAAA,GAAA,EAAA,GAAA,EAAA,IAAA,IAAA,EAAA,IAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,IAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,IAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,EAAA,QAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,GACA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,EAAA,GAAA,IAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,OAAA,EAAA,IAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,SAAA,EAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,IAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,OAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,MAAA,EAAA,GAAA,KAAA,IAAA,EAAA,IAAA,KAAA,IAAA,EAAA,MAAA,EAAA,GAAA,EAAA,IAAA,EAAA,MAAA,SAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAAA,SAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,SAAA,EAAA,EAAA,IAAA,GAAA,OAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,IAAA,EACA,SAA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A,EAAA,EAAA,EAAA,EAAA,MAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,EAAA,MAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KACA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,MAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,EAAA,EAAA,KAAA,GAAA,EAAA,EAAA,EAAA,MAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,IAAA,EAAA,IAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,IAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CAAA,GAAA,IAAA,EAAA,EAAA,OAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,IAAA,EAAA,GAA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A,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,SAAA,EAAA,EAAA,GAAA,KAAA,EAAA,GAAA,KAAA,KAAA,EAAA,GAAA,KAAA,KAAA,EAAA,KAAA,KAAA,GAAA,EAAA,SAAA,IAAA,KAAA,EAAA,KAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,KAAA,KAAA,EAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,EAAA,EAAA,SAAA,IAAA,KAAA,EAAA,IAAA,GAAA,KAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA,KAAA,EAAA,IAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,KAAA,EAAA,EAAA,KAAA,EAAA,SAAA,GAAA,EAAA,GAAA,KAAA,EAAA,GAAA,KAAA,KAAA,EAAA,GAAA,KAAA,KAAA,EAAA,KAAA,EAAA,KAAA,KAAA,EAAA,CAAA,EAAA,EAAA,GAAA,KAAA,EAAA,KAAA,EAAA,KAAA,EAAA,EAAA,SAAA,KAAA,KAAA,EAAA,GAAA,KAAA,EAAA,KAAA,KAAA,EAAA,EAAA,KAAA,GAAA,EAAA,KAAA,EAAA,IAAA,GAAA,SAAA,GAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,KAAA,SAAA,GAAA,OAAA,SAAA,EAAA,GAAA,OAAA,EAAA,EAAA,GAAA,EAAA,IAAA,GAAA,GAAA,CAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,SAAA,GAAA,EAAA,GAAA,GAAA,EAAA,EAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,OAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,EAA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A,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,KAAA,EAAA,GAAA,EAAA,EAAA,GAAA,GAAA,GAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,MAAA,CAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,CAAA,EAAA,EAAA,GAAA,EAAA,CAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,EAAA,CAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EACA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,GAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAAA,GAAA,GAAA,EAAA,IAAA,EAAA,EAAA,GAAA,EAAA,KAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAA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","file":"index.js","sourceRoot":"..","sourcesContent":["/*\n\n Copyright 2000, Silicon Graphics, Inc. All Rights Reserved.\n Copyright 2015, Google Inc. All Rights Reserved.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to\n deal in the Software without restriction, including without limitation the\n rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n sell copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice including the dates of first publication and\n either this permission notice or a reference to http://oss.sgi.com/projects/FreeB/\n shall be included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n Original Code. The Original Code is: OpenGL Sample Implementation,\n Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,\n Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.\n Copyright in any portions created by third parties is as indicated\n elsewhere herein. All Rights Reserved.\n*/\n'use strict';var n;function t(a,b){return a.b===b.b&&a.a===b.a}function u(a,b){return a.b<b.b||a.b===b.b&&a.a<=b.a}function v(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?d<e?b.a-a.a+d/(d+e)*(a.a-c.a):b.a-c.a+e/(d+e)*(c.a-a.a):0}function x(a,b,c){var d=b.b-a.b,e=c.b-b.b;return 0<d+e?(b.a-c.a)*d+(b.a-a.a)*e:0}function z(a,b){return a.a<b.a||a.a===b.a&&a.b<=b.b}function aa(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?d<e?b.b-a.b+d/(d+e)*(a.b-c.b):b.b-c.b+e/(d+e)*(c.b-a.b):0}\nfunction ba(a,b,c){var d=b.a-a.a,e=c.a-b.a;return 0<d+e?(b.b-c.b)*d+(b.b-a.b)*e:0}function ca(a){return u(a.b.a,a.a)}function da(a){return u(a.a,a.b.a)}function A(a,b,c,d){a=0>a?0:a;c=0>c?0:c;return a<=c?0===c?(b+d)/2:b+a/(a+c)*(d-b):d+c/(a+c)*(b-d)};function ea(a){var b=B(a.b);C(b,a.c);C(b.b,a.c);D(b,a.a);return b}function E(a,b){var c=!1,d=!1;a!==b&&(b.a!==a.a&&(d=!0,F(b.a,a.a)),b.d!==a.d&&(c=!0,G(b.d,a.d)),H(b,a),d||(C(b,a.a),a.a.c=a),c||(D(b,a.d),a.d.a=a))}function I(a){var b=a.b,c=!1;a.d!==a.b.d&&(c=!0,G(a.d,a.b.d));a.c===a?F(a.a,null):(a.b.d.a=J(a),a.a.c=a.c,H(a,J(a)),c||D(a,a.d));b.c===b?(F(b.a,null),G(b.d,null)):(a.d.a=J(b),b.a.c=b.c,H(b,J(b)));fa(a)}\nfunction K(a){var b=B(a),c=b.b;H(b,a.e);b.a=a.b.a;C(c,b.a);b.d=c.d=a.d;b=b.b;H(a.b,J(a.b));H(a.b,b);a.b.a=b.a;b.b.a.c=b.b;b.b.d=a.b.d;b.f=a.f;b.b.f=a.b.f;return b}function L(a,b){var c=!1,d=B(a),e=d.b;b.d!==a.d&&(c=!0,G(b.d,a.d));H(d,a.e);H(e,b);d.a=a.b.a;e.a=b.a;d.d=e.d=a.d;a.d.a=e;c||D(d,a.d);return d}function B(a){var b=new M,c=new M,d=a.b.h;c.h=d;d.b.h=b;b.h=a;a.b.h=c;b.b=c;b.c=b;b.e=c;c.b=b;c.c=c;return c.e=b}function H(a,b){var c=a.c,d=b.c;c.b.e=b;d.b.e=a;a.c=d;b.c=c}\nfunction C(a,b){var c=b.f,d=new N(b,c);c.e=d;b.f=d;c=d.c=a;do c.a=d,c=c.c;while(c!==a)}function D(a,b){var c=b.d,d=new ga(b,c);c.b=d;b.d=d;d.a=a;d.c=b.c;c=a;do c.d=d,c=c.e;while(c!==a)}function fa(a){var b=a.h;a=a.b.h;b.b.h=a;a.b.h=b}function F(a,b){var c=a.c,d=c;do d.a=b,d=d.c;while(d!==c);c=a.f;d=a.e;d.f=c;c.e=d}function G(a,b){var c=a.a,d=c;do d.d=b,d=d.e;while(d!==c);c=a.d;d=a.b;d.d=c;c.b=d};function ha(a){var b=0;Math.abs(a[1])>Math.abs(a[0])&&(b=1);Math.abs(a[2])>Math.abs(a[b])&&(b=2);return b};var O=4*1E150;function P(a,b){a.f+=b.f;a.b.f+=b.b.f}function ia(a,b,c){a=a.a;b=b.a;c=c.a;if(b.b.a===a)return c.b.a===a?u(b.a,c.a)?0>=x(c.b.a,b.a,c.a):0<=x(b.b.a,c.a,b.a):0>=x(c.b.a,a,c.a);if(c.b.a===a)return 0<=x(b.b.a,a,b.a);b=v(b.b.a,a,b.a);a=v(c.b.a,a,c.a);return b>=a}function Q(a){a.a.i=null;var b=a.e;b.a.c=b.c;b.c.a=b.a;a.e=null}function ja(a,b){I(a.a);a.c=!1;a.a=b;b.i=a}function ka(a){var b=a.a.a;do a=R(a);while(a.a.a===b);a.c&&(b=L(S(a).a.b,a.a.e),ja(a,b),a=R(a));return a}\nfunction la(a,b,c){var d=new ma;d.a=c;d.e=na(a.f,b.e,d);return c.i=d}function oa(a,b){switch(a.s){case 100130:return 0!==(b&1);case 100131:return 0!==b;case 100132:return 0<b;case 100133:return 0>b;case 100134:return 2<=b||-2>=b}return!1}function pa(a){var b=a.a,c=b.d;c.c=a.d;c.a=b;Q(a)}function T(a,b,c){a=b;for(b=b.a;a!==c;){a.c=!1;var d=S(a),e=d.a;if(e.a!==b.a){if(!d.c){pa(a);break}e=L(b.c.b,e.b);ja(d,e)}b.c!==e&&(E(J(e),e),E(b,e));pa(a);b=d.a;a=d}return b}\nfunction U(a,b,c,d,e,f){var g=!0;do la(a,b,c.b),c=c.c;while(c!==d);for(null===e&&(e=S(b).a.b.c);;){d=S(b);c=d.a.b;if(c.a!==e.a)break;c.c!==e&&(E(J(c),c),E(J(e),c));d.f=b.f-c.f;d.d=oa(a,d.f);b.b=!0;!g&&qa(a,b)&&(P(c,e),Q(b),I(e));g=!1;b=d;e=c}b.b=!0;f&&ra(a,b)}function sa(a,b,c,d,e){var f=[b.g[0],b.g[1],b.g[2]];b.d=null;b.d=a.o?a.o(f,c,d,a.c)||null:null;null===b.d&&(e?a.n||(V(a,100156),a.n=!0):b.d=c[0])}\nfunction ta(a,b,c){var d=[null,null,null,null];d[0]=b.a.d;d[1]=c.a.d;sa(a,b.a,d,[.5,.5,0,0],!1);E(b,c)}function ua(a,b,c,d,e){var f=Math.abs(b.b-a.b)+Math.abs(b.a-a.a),g=Math.abs(c.b-a.b)+Math.abs(c.a-a.a),h=e+1;d[e]=.5*g/(f+g);d[h]=.5*f/(f+g);a.g[0]+=d[e]*b.g[0]+d[h]*c.g[0];a.g[1]+=d[e]*b.g[1]+d[h]*c.g[1];a.g[2]+=d[e]*b.g[2]+d[h]*c.g[2]}\nfunction qa(a,b){var c=S(b),d=b.a,e=c.a;if(u(d.a,e.a)){if(0<x(e.b.a,d.a,e.a))return!1;if(!t(d.a,e.a))K(e.b),E(d,J(e)),b.b=c.b=!0;else if(d.a!==e.a){var c=a.e,f=d.a.h;if(0<=f){var c=c.b,g=c.d,h=c.e,k=c.c,l=k[f];g[l]=g[c.a];k[g[l]]=l;l<=--c.a&&(1>=l?W(c,l):u(h[g[l>>1]],h[g[l]])?W(c,l):va(c,l));h[f]=null;k[f]=c.b;c.b=f}else for(c.c[-(f+1)]=null;0<c.a&&null===c.c[c.d[c.a-1]];)--c.a;ta(a,J(e),d)}}else{if(0>x(d.b.a,e.a,d.a))return!1;R(b).b=b.b=!0;K(d.b);E(J(e),d)}return!0}\nfunction wa(a,b){var c=S(b),d=b.a,e=c.a,f=d.a,g=e.a,h=d.b.a,k=e.b.a,l=new N;x(h,a.a,f);x(k,a.a,g);if(f===g||Math.min(f.a,h.a)>Math.max(g.a,k.a))return!1;if(u(f,g)){if(0<x(k,f,g))return!1}else if(0>x(h,g,f))return!1;var r=h,p=f,q=k,y=g,m,w;u(r,p)||(m=r,r=p,p=m);u(q,y)||(m=q,q=y,y=m);u(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);u(q,p)?u(p,y)?(m=v(r,q,p),w=v(q,p,y),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,p.b)):(m=x(r,q,p),w=-x(r,y,p),0>m+w&&(m=-m,w=-w),l.b=A(m,q.b,w,y.b)):l.b=(q.b+p.b)/2;z(r,p)||(m=r,r=p,p=m);z(q,y)||\n(m=q,q=y,y=m);z(r,q)||(m=r,r=q,q=m,m=p,p=y,y=m);z(q,p)?z(p,y)?(m=aa(r,q,p),w=aa(q,p,y),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,p.a)):(m=ba(r,q,p),w=-ba(r,y,p),0>m+w&&(m=-m,w=-w),l.a=A(m,q.a,w,y.a)):l.a=(q.a+p.a)/2;u(l,a.a)&&(l.b=a.a.b,l.a=a.a.a);r=u(f,g)?f:g;u(r,l)&&(l.b=r.b,l.a=r.a);if(t(l,f)||t(l,g))return qa(a,b),!1;if(!t(h,a.a)&&0<=x(h,a.a,l)||!t(k,a.a)&&0>=x(k,a.a,l)){if(k===a.a)return K(d.b),E(e.b,d),b=ka(b),d=S(b).a,T(a,S(b),c),U(a,b,J(d),d,d,!0),!0;if(h===a.a){K(e.b);E(d.e,J(e));f=c=b;g=f.a.b.a;\ndo f=R(f);while(f.a.b.a===g);b=f;f=S(b).a.b.c;c.a=J(e);e=T(a,c,null);U(a,b,e.c,d.b.c,f,!0);return!0}0<=x(h,a.a,l)&&(R(b).b=b.b=!0,K(d.b),d.a.b=a.a.b,d.a.a=a.a.a);0>=x(k,a.a,l)&&(b.b=c.b=!0,K(e.b),e.a.b=a.a.b,e.a.a=a.a.a);return!1}K(d.b);K(e.b);E(J(e),d);d.a.b=l.b;d.a.a=l.a;d.a.h=xa(a.e,d.a);d=d.a;e=[0,0,0,0];l=[f.d,h.d,g.d,k.d];d.g[0]=d.g[1]=d.g[2]=0;ua(d,f,h,e,0);ua(d,g,k,e,2);sa(a,d,l,e,!0);R(b).b=b.b=c.b=!0;return!1}\nfunction ra(a,b){for(var c=S(b);;){for(;c.b;)b=c,c=S(c);if(!b.b&&(c=b,b=R(b),null===b||!b.b))break;b.b=!1;var d=b.a,e=c.a,f;if(f=d.b.a!==e.b.a)a:{f=b;var g=S(f),h=f.a,k=g.a,l=void 0;if(u(h.b.a,k.b.a)){if(0>x(h.b.a,k.b.a,h.a)){f=!1;break a}R(f).b=f.b=!0;l=K(h);E(k.b,l);l.d.c=f.d}else{if(0<x(k.b.a,h.b.a,k.a)){f=!1;break a}f.b=g.b=!0;l=K(k);E(h.e,k.b);l.b.d.c=f.d}f=!0}f&&(c.c?(Q(c),I(e),c=S(b),e=c.a):b.c&&(Q(b),I(d),b=R(c),d=b.a));if(d.a!==e.a)if(d.b.a===e.b.a||b.c||c.c||d.b.a!==a.a&&e.b.a!==a.a)qa(a,\nb);else if(wa(a,b))break;d.a===e.a&&d.b.a===e.b.a&&(P(e,d),Q(b),I(d),b=R(c))}}\nfunction ya(a,b){a.a=b;for(var c=b.c;null===c.i;)if(c=c.c,c===b.c){var c=a,d=b,e=new ma;e.a=d.c.b;var f=c.f,g=f.a;do g=g.a;while(null!==g.b&&!f.c(f.b,e,g.b));var f=g.b,h=S(f),e=f.a,g=h.a;if(0===x(e.b.a,d,e.a))e=f.a,t(e.a,d)||t(e.b.a,d)||(K(e.b),f.c&&(I(e.c),f.c=!1),E(d.c,e),ya(c,d));else{var k=u(g.b.a,e.b.a)?f:h,h=void 0;f.d||k.c?(k===f?h=L(d.c.b,e.e):h=L(g.b.c.b,d.c).b,k.c?ja(k,h):(e=c,f=la(c,f,h),f.f=R(f).f+f.a.f,f.d=oa(e,f.f)),ya(c,d)):U(c,f,d.c,d.c,null,!0)}return}c=ka(c.i);e=S(c);f=e.a;e=T(a,\ne,null);if(e.c===f){var f=e,e=f.c,g=S(c),h=c.a,k=g.a,l=!1;h.b.a!==k.b.a&&wa(a,c);t(h.a,a.a)&&(E(J(e),h),c=ka(c),e=S(c).a,T(a,S(c),g),l=!0);t(k.a,a.a)&&(E(f,J(k)),f=T(a,g,null),l=!0);l?U(a,c,f.c,e,e,!0):(u(k.a,h.a)?d=J(k):d=h,d=L(f.c.b,d),U(a,c,d,d.c,d.c,!1),d.b.i.c=!0,ra(a,c))}else U(a,c,e.c,f,f,!0)}function za(a,b){var c=new ma,d=ea(a.b);d.a.b=O;d.a.a=b;d.b.a.b=-O;d.b.a.a=b;a.a=d.b.a;c.a=d;c.f=0;c.d=!1;c.c=!1;c.h=!0;c.b=!1;d=a.f;d=na(d,d.a,c);c.e=d};function Aa(a){this.a=new Ba;this.b=a;this.c=ia}function na(a,b,c){do b=b.c;while(null!==b.b&&!a.c(a.b,b.b,c));a=new Ba(c,b.a,b);b.a.c=a;return b.a=a};function Ba(a,b,c){this.b=a||null;this.a=b||this;this.c=c||this};function X(){this.d=Y;this.p=this.b=this.q=null;this.j=[0,0,0];this.s=100130;this.n=!1;this.o=this.a=this.e=this.f=null;this.m=!1;this.c=this.r=this.i=this.k=this.l=this.h=null}var Y=0;n=X.prototype;n.x=function(){Z(this,Y)};n.B=function(a,b){switch(a){case 100142:return;case 100140:switch(b){case 100130:case 100131:case 100132:case 100133:case 100134:this.s=b;return}break;case 100141:this.m=!!b;return;default:V(this,100900);return}V(this,100901)};\nn.y=function(a){switch(a){case 100142:return 0;case 100140:return this.s;case 100141:return this.m;default:V(this,100900)}return!1};n.A=function(a,b,c){this.j[0]=a;this.j[1]=b;this.j[2]=c};\nn.z=function(a,b){var c=b?b:null;switch(a){case 100100:case 100106:this.h=c;break;case 100104:case 100110:this.l=c;break;case 100101:case 100107:this.k=c;break;case 100102:case 100108:this.i=c;break;case 100103:case 100109:this.p=c;break;case 100105:case 100111:this.o=c;break;case 100112:this.r=c;break;default:V(this,100900)}};\nn.C=function(a,b){var c=!1,d=[0,0,0];Z(this,2);for(var e=0;3>e;++e){var f=a[e];-1E150>f&&(f=-1E150,c=!0);1E150<f&&(f=1E150,c=!0);d[e]=f}c&&V(this,100155);c=this.q;null===c?(c=ea(this.b),E(c,c.b)):(K(c),c=c.e);c.a.d=b;c.a.g[0]=d[0];c.a.g[1]=d[1];c.a.g[2]=d[2];c.f=1;c.b.f=-1;this.q=c};n.u=function(a){Z(this,Y);this.d=1;this.b=new Ca;this.c=a};n.t=function(){Z(this,1);this.d=2;this.q=null};n.v=function(){Z(this,2);this.d=1};\nn.w=function(){Z(this,1);this.d=Y;var a=this.j[0],b=this.j[1],c=this.j[2],d=!1,e=[a,b,c];if(0===a&&0===b&&0===c){for(var b=[-2*1E150,-2*1E150,-2*1E150],f=[2*1E150,2*1E150,2*1E150],c=[],g=[],d=this.b.c,a=d.e;a!==d;a=a.e)for(var h=0;3>h;++h){var k=a.g[h];k<f[h]&&(f[h]=k,g[h]=a);k>b[h]&&(b[h]=k,c[h]=a)}a=0;b[1]-f[1]>b[0]-f[0]&&(a=1);b[2]-f[2]>b[a]-f[a]&&(a=2);if(f[a]>=b[a])e[0]=0,e[1]=0,e[2]=1;else{b=0;f=g[a];c=c[a];g=[0,0,0];f=[f.g[0]-c.g[0],f.g[1]-c.g[1],f.g[2]-c.g[2]];h=[0,0,0];for(a=d.e;a!==d;a=\na.e)h[0]=a.g[0]-c.g[0],h[1]=a.g[1]-c.g[1],h[2]=a.g[2]-c.g[2],g[0]=f[1]*h[2]-f[2]*h[1],g[1]=f[2]*h[0]-f[0]*h[2],g[2]=f[0]*h[1]-f[1]*h[0],k=g[0]*g[0]+g[1]*g[1]+g[2]*g[2],k>b&&(b=k,e[0]=g[0],e[1]=g[1],e[2]=g[2]);0>=b&&(e[0]=e[1]=e[2]=0,e[ha(f)]=1)}d=!0}g=ha(e);a=this.b.c;b=(g+1)%3;c=(g+2)%3;g=0<e[g]?1:-1;for(e=a.e;e!==a;e=e.e)e.b=e.g[b],e.a=g*e.g[c];if(d){e=0;d=this.b.a;for(a=d.b;a!==d;a=a.b)if(b=a.a,!(0>=b.f)){do e+=(b.a.b-b.b.a.b)*(b.a.a+b.b.a.a),b=b.e;while(b!==a.a)}if(0>e)for(e=this.b.c,d=e.e;d!==\ne;d=d.e)d.a=-d.a}this.n=!1;e=this.b.b;for(a=e.h;a!==e;a=d)if(d=a.h,b=a.e,t(a.a,a.b.a)&&a.e.e!==a&&(ta(this,b,a),I(a),a=b,b=a.e),b.e===a){if(b!==a){if(b===d||b===d.b)d=d.h;I(b)}if(a===d||a===d.b)d=d.h;I(a)}this.e=e=new Da;d=this.b.c;for(a=d.e;a!==d;a=a.e)a.h=xa(e,a);Ea(e);this.f=new Aa(this);za(this,-O);for(za(this,O);null!==(e=Fa(this.e));){for(;;){a:if(a=this.e,0===a.a)d=Ga(a.b);else if(d=a.c[a.d[a.a-1]],0!==a.b.a&&(a=Ga(a.b),u(a,d))){d=a;break a}if(null===d||!t(d,e))break;d=Fa(this.e);ta(this,e.c,\nd.c)}ya(this,e)}this.a=this.f.a.a.b.a.a;for(e=0;null!==(d=this.f.a.a.b);)d.h||++e,Q(d);this.f=null;e=this.e;e.b=null;e.d=null;this.e=e.c=null;e=this.b;for(a=e.a.b;a!==e.a;a=d)d=a.b,a=a.a,a.e.e===a&&(P(a.c,a),I(a));if(!this.n){e=this.b;if(this.m)for(a=e.b.h;a!==e.b;a=d)d=a.h,a.b.d.c!==a.d.c?a.f=a.d.c?1:-1:I(a);else for(a=e.a.b;a!==e.a;a=d)if(d=a.b,a.c){for(a=a.a;u(a.b.a,a.a);a=a.c.b);for(;u(a.a,a.b.a);a=a.e);b=a.c.b;for(c=void 0;a.e!==b;)if(u(a.b.a,b.a)){for(;b.e!==a&&(ca(b.e)||0>=x(b.a,b.b.a,b.e.b.a));)c=\nL(b.e,b),b=c.b;b=b.c.b}else{for(;b.e!==a&&(da(a.c.b)||0<=x(a.b.a,a.a,a.c.b.a));)c=L(a,a.c.b),a=c.b;a=a.e}for(;b.e.e!==a;)c=L(b.e,b),b=c.b}if(this.h||this.i||this.k||this.l)if(this.m)for(e=this.b,d=e.a.b;d!==e.a;d=d.b){if(d.c){this.h&&this.h(2,this.c);a=d.a;do this.k&&this.k(a.a.d,this.c),a=a.e;while(a!==d.a);this.i&&this.i(this.c)}}else{e=this.b;d=!!this.l;a=!1;b=-1;for(c=e.a.d;c!==e.a;c=c.d)if(c.c){a||(this.h&&this.h(4,this.c),a=!0);g=c.a;do d&&(f=g.b.d.c?0:1,b!==f&&(b=f,this.l&&this.l(!!b,this.c))),\nthis.k&&this.k(g.a.d,this.c),g=g.e;while(g!==c.a)}a&&this.i&&this.i(this.c)}if(this.r){e=this.b;for(a=e.a.b;a!==e.a;a=d)if(d=a.b,!a.c){b=a.a;c=b.e;g=void 0;do g=c,c=g.e,g.d=null,null===g.b.d&&(g.c===g?F(g.a,null):(g.a.c=g.c,H(g,J(g))),f=g.b,f.c===f?F(f.a,null):(f.a.c=f.c,H(f,J(f))),fa(g));while(g!==b);b=a.d;a=a.b;a.d=b;b.b=a}this.r(this.b);this.c=this.b=null;return}}this.b=this.c=null};\nfunction Z(a,b){if(a.d!==b)for(;a.d!==b;)if(a.d<b)switch(a.d){case Y:V(a,100151);a.u(null);break;case 1:V(a,100152),a.t()}else switch(a.d){case 2:V(a,100154);a.v();break;case 1:V(a,100153),a.w()}}function V(a,b){a.p&&a.p(b,a.c)};function ga(a,b){this.b=a||this;this.d=b||this;this.a=null;this.c=!1};function M(){this.h=this;this.i=this.d=this.a=this.e=this.c=this.b=null;this.f=0}function J(a){return a.b.e};function Ca(){this.c=new N;this.a=new ga;this.b=new M;this.d=new M;this.b.b=this.d;this.d.b=this.b};function N(a,b){this.e=a||this;this.f=b||this;this.d=this.c=null;this.g=[0,0,0];this.h=this.a=this.b=0};function Da(){this.c=[];this.d=null;this.a=0;this.e=!1;this.b=new Ha}function Ea(a){a.d=[];for(var b=0;b<a.a;b++)a.d[b]=b;a.d.sort(function(a){return function(b,e){return u(a[b],a[e])?1:-1}}(a.c));a.e=!0;Ia(a.b)}function xa(a,b){if(a.e){var c=a.b,d=++c.a;2*d>c.f&&(c.f*=2,c.c=Ja(c.c,c.f+1));var e;0===c.b?e=d:(e=c.b,c.b=c.c[c.b]);c.e[e]=b;c.c[e]=d;c.d[d]=e;c.h&&va(c,d);return e}c=a.a++;a.c[c]=b;return-(c+1)}\nfunction Fa(a){if(0===a.a)return Ka(a.b);var b=a.c[a.d[a.a-1]];if(0!==a.b.a&&u(Ga(a.b),b))return Ka(a.b);do--a.a;while(0<a.a&&null===a.c[a.d[a.a-1]]);return b};function Ha(){this.d=Ja([0],33);this.e=[null,null];this.c=[0,0];this.a=0;this.f=32;this.b=0;this.h=!1;this.d[1]=1}function Ja(a,b){for(var c=Array(b),d=0;d<a.length;d++)c[d]=a[d];for(;d<b;d++)c[d]=0;return c}function Ia(a){for(var b=a.a;1<=b;--b)W(a,b);a.h=!0}function Ga(a){return a.e[a.d[1]]}function Ka(a){var b=a.d,c=a.e,d=a.c,e=b[1],f=c[e];0<a.a&&(b[1]=b[a.a],d[b[1]]=1,c[e]=null,d[e]=a.b,a.b=e,0<--a.a&&W(a,1));return f}\nfunction W(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f<<1;h<a.a&&u(d[c[h+1]],d[c[h]])&&(h+=1);var k=c[h];if(h>a.a||u(d[g],d[k])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}}function va(a,b){for(var c=a.d,d=a.e,e=a.c,f=b,g=c[f];;){var h=f>>1,k=c[h];if(0===h||u(d[k],d[g])){c[f]=g;e[g]=f;break}c[f]=k;e[k]=f;f=h}};function ma(){this.e=this.a=null;this.f=0;this.c=this.b=this.h=this.d=!1}function S(a){return a.e.c.b}function R(a){return a.e.a.b};this.libtess={GluTesselator:X,windingRule:{GLU_TESS_WINDING_ODD:100130,GLU_TESS_WINDING_NONZERO:100131,GLU_TESS_WINDING_POSITIVE:100132,GLU_TESS_WINDING_NEGATIVE:100133,GLU_TESS_WINDING_ABS_GEQ_TWO:100134},primitiveType:{GL_LINE_LOOP:2,GL_TRIANGLES:4,GL_TRIANGLE_STRIP:5,GL_TRIANGLE_FAN:6},errorType:{GLU_TESS_MISSING_BEGIN_POLYGON:100151,GLU_TESS_MISSING_END_POLYGON:100153,GLU_TESS_MISSING_BEGIN_CONTOUR:100152,GLU_TESS_MISSING_END_CONTOUR:100154,GLU_TESS_COORD_TOO_LARGE:100155,GLU_TESS_NEED_COMBINE_CALLBACK:100156},\ngluEnum:{GLU_TESS_MESH:100112,GLU_TESS_TOLERANCE:100142,GLU_TESS_WINDING_RULE:100140,GLU_TESS_BOUNDARY_ONLY:100141,GLU_INVALID_ENUM:100900,GLU_INVALID_VALUE:100901,GLU_TESS_BEGIN:100100,GLU_TESS_VERTEX:100101,GLU_TESS_END:100102,GLU_TESS_ERROR:100103,GLU_TESS_EDGE_FLAG:100104,GLU_TESS_COMBINE:100105,GLU_TESS_BEGIN_DATA:100106,GLU_TESS_VERTEX_DATA:100107,GLU_TESS_END_DATA:100108,GLU_TESS_ERROR_DATA:100109,GLU_TESS_EDGE_FLAG_DATA:100110,GLU_TESS_COMBINE_DATA:100111}};X.prototype.gluDeleteTess=X.prototype.x;\nX.prototype.gluTessProperty=X.prototype.B;X.prototype.gluGetTessProperty=X.prototype.y;X.prototype.gluTessNormal=X.prototype.A;X.prototype.gluTessCallback=X.prototype.z;X.prototype.gluTessVertex=X.prototype.C;X.prototype.gluTessBeginPolygon=X.prototype.u;X.prototype.gluTessBeginContour=X.prototype.t;X.prototype.gluTessEndContour=X.prototype.v;X.prototype.gluTessEndPolygon=X.prototype.w; if (typeof module !== 'undefined') { module.exports = this.libtess; }\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cross = cross;\nexports.length = length;\nexports.dot = dot;\nexports.normalize = normalize;\nexports.add = add;\nexports.subtract = subtract;\n/**\n * @module vec\n */\n\n/**\n * Cross product\n *\n * @param {Array} a First vector\n * @param {Array} b Second vector\n *\n * @return {Array}\n */\nfunction cross(a, b) {\n  a = a.length === 2 ? [a[0], a[1], 0] : a;\n  b = b.length === 2 ? [b[0], b[1], 0] : b;\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n/**\n * Length of vector\n *\n * @param {Array} v Vector\n *\n * @return {Number}\n */\nfunction length(v) {\n  return Math.sqrt(v.slice(0, 3).reduce(function (p, w, i) {\n    return p + w * w;\n  }, 0));\n}\n\n/**\n * Dot product\n *\n * @param {Array} a Vector\n * @param {Array} b Vector\n *\n * @return {Number}\n */\nfunction dot(a, b) {\n  return a.reduce(function (p, v, i) {\n    return p + v * b[i];\n  }, 0);\n}\n\n/**\n * Normalize a vector\n *\n * @param {Array} v Vector\n *\n * @return {Array}\n */\nfunction normalize(v) {\n  var len = length(v);\n  return v.slice(0, 3).map(function (i) {\n    return i / len;\n  });\n}\n\n/**\n * Add\n *\n * @param {Array} a First vector\n * @param {Array} b Second vector\n *\n * @return {Array}\n */\nfunction add(a, b) {\n  return a.slice(0, 3).map(function (v, i) {\n    return v + b[i];\n  });\n}\n\n/**\n * Subtract\n *\n * @param {Array} a First vector\n * @param {Array} b Second vector\n *\n * @return {Array}\n */\nfunction subtract(a, b) {\n  return a.slice(0, 3).map(function (v, i) {\n    return v - b[i];\n  });\n}\n\nvar sub = exports.sub = subtract;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WINDING_CW = exports.WINDING_CCW = exports.WINDING_UNKNOWN = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @module polygon\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\n\nexports.ccw = ccw;\nexports.normal = normal;\nexports.area = area;\nexports.centroid = centroid;\nexports.is_ccw = is_ccw;\nexports.is_cw = is_cw;\nexports.winding = winding;\nexports.bounds = bounds;\nexports.ensure_cw = ensure_cw;\nexports.ensure_ccw = ensure_ccw;\nexports.triangulate = triangulate;\nexports.subtract = subtract;\nexports.union = union;\nexports.intersection = intersection;\n\nvar _tesselator = require('./tesselator');\n\nvar tess = _interopRequireWildcard(_tesselator);\n\nvar _vec = require('./vec');\n\nvar vec = _interopRequireWildcard(_vec);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar WINDING_UNKNOWN = exports.WINDING_UNKNOWN = 0;\nvar WINDING_CCW = exports.WINDING_CCW = 1;\nvar WINDING_CW = exports.WINDING_CW = 2;\n\nfunction ccw(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\n}\n\n/**\n * Polygon normal (2d / 3d)\n *\n * @param {Array} pts Points of the polygon\n * @param {Boolean} [forceNewell=false] Whether to force Newell's method\n *\n * @return {Array} Polygon normal or null if the polygon is degenerate\n */\nfunction normal(pts) {\n  var forceNewell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\n  if (pts.length < 3) return null;\n\n  var vs = pts.map(function (p) {\n    return p.length >= 3 ? p : [p[0], p[1], 0];\n  });\n\n  if (!forceNewell) {\n    var _vs = _slicedToArray(vs, 3),\n        a = _vs[0],\n        b = _vs[1],\n        c = _vs[2],\n        ba = vec.subtract(b, a),\n        ca = vec.subtract(c, a),\n        cr = vec.normalize(vec.cross(ba, ca));\n\n    if (cr.some(function (v) {\n      return isNaN(v);\n    })) {\n      if (pts.length === 3) return null;\n    } else {\n      return cr;\n    }\n  }\n\n  // fallback to Newell's method\n  var n = [0, 0, 0];\n  vs.forEach(function (v, i) {\n    var w = vs[(i + 1) % pts.length];\n    n[0] = n[0] + (v[1] - w[1]) * (v[2] + w[2]);\n    n[1] = n[1] + (v[2] - w[2]) * (v[0] + w[0]);\n    n[2] = n[2] + (v[0] - w[0]) * (v[1] + w[1]);\n  });\n\n  n = vec.normalize(n);\n\n  return n.some(function (v) {\n    return isNaN(v);\n  }) ? null : n;\n}\n\n/**\n * Signed area of a polygon.\n * For 3d polygons a signed area can only be computed when the optional\n * polygon normal ```n``` is passed in.\n * @see http://stackoverflow.com/questions/12642256/python-find-area-of-polygon-from-xyz-coordinates\n *\n * @param {Array} pts Polygon points\n * @param {Array} [n=null] Optional polygon normal, needed to compute the signed area for 3d polygons\n *\n * @return {Number}\n */\nfunction area(pts) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (pts.length < 3) return 0;\n  if (pts[0].length < 3) {\n    return pts.reduce(function (a, p, i) {\n      var pn = pts[i + 1] || pts[0];\n      return a + p[0] * pn[1] - pn[0] * p[1];\n    }, 0) / 2;\n  } else {\n    var num = pts.length,\n        nrm = n || normal(pts),\n        total = [0, 0, 0];\n    if (!nrm) return 0;\n    for (var i = 0; i < num; ++i) {\n      var v = pts[i],\n          w = pts[(i + 1) % num];\n      total = vec.add(total, vec.cross(v, w));\n    }\n    return vec.dot(total, nrm) / 2;\n  }\n}\n\n/**\n * Polygon centroid (2d)\n *\n * @param {Array} pts\n *\n * @return {Array}\n */\nfunction centroid(pts) {\n  var _pts$reduce = pts.reduce(function (_ref, p, i) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        x = _ref2[0],\n        y = _ref2[1];\n\n    var pn = pts[i + 1] || pts[0],\n        c = p[0] * pn[1] - pn[0] * p[1];\n    return [x + (p[0] + pn[0]) * c, y + (p[1] + pn[1]) * c];\n  }, [0, 0]),\n      _pts$reduce2 = _slicedToArray(_pts$reduce, 2),\n      x = _pts$reduce2[0],\n      y = _pts$reduce2[1];\n\n  var ar = area(pts);\n  if (x !== 0) {\n    x = x / (Math.abs(ar) * 6);\n  }\n  if (y !== 0) {\n    y = y / (Math.abs(ar) * 6);\n  }\n\n  if (ar < 0) {\n    x = -x;\n    y = -y;\n  }\n  return [x, y];\n}\n\n/**\n * Tests wether the polygon winding is counter clockwise\n *\n * @param {Array} pts\n * @param {Array} [n=null] Optional polygon normal, needed for 3d polygons\n *\n * @return {Boolean}\n */\nfunction is_ccw(pts) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  return area(pts, n) > 0;\n}\n\n/**\n * Tests wether the polygon winding is clockwise\n *\n * @param {Array} pts\n * @param {Array} [n=null] Optional polygon normal, needed for 3d polygons\n *\n * @return {Boolean}\n */\nfunction is_cw(pts) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  return area(pts, n) < 0;\n}\n\n/**\n * Polygon winding (2d only)\n *\n * @param {Array} pts\n * @param {Array} [n=null] Optional polygon normal, needed for 3d polygons\n *\n * @return {Number}\n */\nfunction winding(pts) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  var a = area(pts, n);\n  if (a < 0) return WINDING_CW;\n  if (a > 0) return WINDING_CCW;\n  return WINDING_UNKNOWN;\n}\n\n/**\n * Polygon bounds.\n * @typedef {Object} PolygonBounds\n * @property {Number} xMin\n * @property {Number} yMin\n * @property {Number} xMax\n * @property {Number} yMax\n */\n\n/**\n * Polygon bounds\n *\n * @param {Array} pts\n *\n * @return {PolygonBounds}\n */\nfunction bounds(pts) {\n  var min = [Number.MAX_VALUE, Number.MAX_VALUE],\n      max = [-Number.MAX_VALUE, -Number.MAX_VALUE];\n\n  pts.forEach(function (p) {\n    for (var i = 0; i < Math.min(3, p.length); ++i) {\n      min[i] = Math.min(min[i], p[i]);\n      max[i] = Math.max(max[i], p[i]);\n    }\n  });\n\n  return {\n    xMin: min[0],\n    yMin: min[1],\n    xMax: max[0],\n    yMax: max[1]\n  };\n}\n\n/**\n * Ensures CW winding\n *\n * @param {Array} pts\n * @param {Array} [n=null] Optional polygon normal, needed for 3d polygons\n *\n * @return {Array}\n */\nfunction ensure_cw(pts) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (is_ccw(pts, n)) pts.reverse();\n  return pts;\n}\n\n/**\n * Ensures CCW winding\n *\n * @param {Array} pts\n * @param {Array} [n=null] Optional polygon normal, needed for 3d polygons\n *\n * @return {Array}\n */\nfunction ensure_ccw(pts) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (is_cw(pts, n)) pts.reverse();\n  return pts;\n}\n\n/**\n * Triangulates a polygon\n *\n * @param {Array} polygon\n * @param {Array.<Array>} holes\n *\n * @return triangles\n */\nfunction triangulate(polygon, holes) {\n  if (!polygon || polygon.length < 3) return polygon;\n\n  var bp = bounds(polygon);\n\n  holes = holes.filter(function (hole) {\n    var b = bounds(hole),\n        out = b.xMin > bp.xMax || b.yMin > bp.yMax || b.xMax < bp.xMin || b.yMax < bp.yMin;\n    return !out;\n  });\n\n  var options = { polygons: [polygon], holes: holes };\n\n  return tess.run(options).reduce(function (p, v) {\n    return p.concat(v);\n  }, []);\n}\n\n/**\n * Subtract polygons\n *\n * @param {Array} polygons\n *\n * @return {Array}\n */\nfunction subtract() {\n  for (var _len = arguments.length, polygons = Array(_len), _key = 0; _key < _len; _key++) {\n    polygons[_key] = arguments[_key];\n  }\n\n  var options = {\n    polygons: [ensure_ccw(polygons[0])],\n    holes: polygons.slice(1).map(function (p) {\n      return ensure_cw(p);\n    }),\n    boundaryOnly: true,\n    autoWinding: false\n  };\n  return tess.run(options);\n}\n\n/**\n * Union of a set of polygons\n *\n * @param {Array} polygons\n *\n * @return {Array}\n */\nfunction union() {\n  for (var _len2 = arguments.length, polygons = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    polygons[_key2] = arguments[_key2];\n  }\n\n  var options = {\n    polygons: polygons.map(function (p) {\n      return ensure_ccw(p);\n    }),\n    boundaryOnly: true,\n    autoWinding: false\n  };\n  return tess.run(options);\n}\n\n/**\n * Intersection of a set of polygons\n *\n * @param {Array} a First polygon\n * @param {Array} b Second polygon\n *\n * @return {Array}\n */\nfunction intersection(a, b) {\n  var options = {\n    polygons: [ensure_ccw(a), ensure_ccw(b)],\n    boundaryOnly: true,\n    windingRule: tess.GLU_TESS_WINDING_ABS_GEQ_TWO,\n    autoWinding: false\n  };\n  return tess.run(options);\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tesselator = exports.DEFAULT_OPTIONS = exports.GLU_TESS_WINDING_ABS_GEQ_TWO = exports.GLU_TESS_WINDING_NEGATIVE = exports.GLU_TESS_WINDING_POSITIVE = exports.GLU_TESS_WINDING_NONZERO = exports.GLU_TESS_WINDING_ODD = exports.GL_TRIANGLE_FAN = exports.GL_TRIANGLE_STRIP = exports.GL_TRIANGLES = exports.GL_LINE_LOOP = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.run = run;\n\nvar _libtess = require('libtess');\n\nvar _polygon = require('./polygon');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @module tesselator\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar GL_LINE_LOOP = _libtess.primitiveType.GL_LINE_LOOP,\n    GL_TRIANGLES = _libtess.primitiveType.GL_TRIANGLES,\n    GL_TRIANGLE_STRIP = _libtess.primitiveType.GL_TRIANGLE_STRIP,\n    GL_TRIANGLE_FAN = _libtess.primitiveType.GL_TRIANGLE_FAN;\nexports.GL_LINE_LOOP = GL_LINE_LOOP;\nexports.GL_TRIANGLES = GL_TRIANGLES;\nexports.GL_TRIANGLE_STRIP = GL_TRIANGLE_STRIP;\nexports.GL_TRIANGLE_FAN = GL_TRIANGLE_FAN;\nvar GLU_TESS_WINDING_ODD = _libtess.windingRule.GLU_TESS_WINDING_ODD,\n    GLU_TESS_WINDING_NONZERO = _libtess.windingRule.GLU_TESS_WINDING_NONZERO,\n    GLU_TESS_WINDING_POSITIVE = _libtess.windingRule.GLU_TESS_WINDING_POSITIVE,\n    GLU_TESS_WINDING_NEGATIVE = _libtess.windingRule.GLU_TESS_WINDING_NEGATIVE,\n    GLU_TESS_WINDING_ABS_GEQ_TWO = _libtess.windingRule.GLU_TESS_WINDING_ABS_GEQ_TWO;\n\n/**\n * Tesselator options.\n * @typedef {Object} TesselatorOptions\n * @property {Array} [polygons=[]] Array of polygons\n * @property {Array} [holes=[]] Array of holes\n * @property {Number} [vertexSize=2] Vertex size to use\n * @property {Number} [windingRule=GLU_TESS_WINDING_POSITIVE] Winding rule\n * @property {Boolean} [boundaryOnly=false] Whether to output boundaries only\n * @property {Array} [normal=null] Normal\n * @property {Boolean} [autoWinding=true] Whether to automatically set the correct winding on polygons\n */\n\nexports.GLU_TESS_WINDING_ODD = GLU_TESS_WINDING_ODD;\nexports.GLU_TESS_WINDING_NONZERO = GLU_TESS_WINDING_NONZERO;\nexports.GLU_TESS_WINDING_POSITIVE = GLU_TESS_WINDING_POSITIVE;\nexports.GLU_TESS_WINDING_NEGATIVE = GLU_TESS_WINDING_NEGATIVE;\nexports.GLU_TESS_WINDING_ABS_GEQ_TWO = GLU_TESS_WINDING_ABS_GEQ_TWO;\nvar DEFAULT_OPTIONS = exports.DEFAULT_OPTIONS = {\n  polygons: [],\n  holes: [],\n  windingRule: GLU_TESS_WINDING_POSITIVE,\n  boundaryOnly: false,\n  normal: null,\n  autoWinding: true\n};\n\nvar Tesselator = exports.Tesselator = function (_GluTesselator) {\n  _inherits(Tesselator, _GluTesselator);\n\n  function Tesselator() {\n    var vsize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n\n    _classCallCheck(this, Tesselator);\n\n    var _this = _possibleConstructorReturn(this, (Tesselator.__proto__ || Object.getPrototypeOf(Tesselator)).call(this));\n\n    _this._vsize = vsize;\n    _this._current = [];\n    _this._out = [];\n    _this._primitiveType = 0;\n\n    _this.gluTessCallback(_libtess.gluEnum.GLU_TESS_VERTEX_DATA, _this._vertex);\n    _this.gluTessCallback(_libtess.gluEnum.GLU_TESS_BEGIN, _this._begin);\n    _this.gluTessCallback(_libtess.gluEnum.GLU_TESS_END, _this._end);\n    _this.gluTessCallback(_libtess.gluEnum.GLU_TESS_ERROR, _this._error);\n    _this.gluTessCallback(_libtess.gluEnum.GLU_TESS_COMBINE, _this._combine);\n    _this.gluTessCallback(_libtess.gluEnum.GLU_TESS_EDGE_FLAG, _this._edge);\n    return _this;\n  }\n\n  _createClass(Tesselator, [{\n    key: 'start',\n    value: function start(polygons, holes) {\n      this._current = [];\n      this._out = [];\n\n      this.gluTessBeginPolygon();\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = polygons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var poly = _step.value;\n\n          this.gluTessBeginContour();\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = poly[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var v = _step3.value;\n\n              this.gluTessVertex(v, v);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          this.gluTessEndContour();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = holes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _poly = _step2.value;\n\n          this.gluTessBeginContour();\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = _poly[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var _v = _step4.value;\n\n              this.gluTessVertex(_v, _v);\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n\n          this.gluTessEndContour();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.gluTessEndPolygon();\n    }\n  }, {\n    key: 'run',\n    value: function run() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_OPTIONS;\n      var opts = Object.assign({}, DEFAULT_OPTIONS, options),\n          polygons = opts.polygons,\n          holes = opts.holes,\n          autoWinding = opts.autoWinding,\n          boundaryOnly = opts.boundaryOnly;\n\n\n      if (!polygons || !polygons.length) {\n        throw new Error('need at least a single polygon');\n      }\n\n      if (autoWinding) {\n        polygons = polygons.filter(function (p) {\n          return Math.abs((0, _polygon.area)(p)) > 0;\n        }).map(function (p) {\n          if ((0, _polygon.is_cw)(p)) p.reverse();\n          return p;\n        });\n        holes = holes.filter(function (p) {\n          return Math.abs((0, _polygon.area)(p)) > 0;\n        }).map(function (p) {\n          if ((0, _polygon.is_ccw)(p)) p.reverse();\n          return p;\n        });\n      }\n\n      var _ref = opts.normal ? opts.normal : (0, _polygon.normal)(polygons[0], true),\n          _ref2 = _slicedToArray(_ref, 3),\n          nx = _ref2[0],\n          ny = _ref2[1],\n          nz = _ref2[2];\n\n      this.gluTessNormal(nx, ny, nz);\n      this.gluTessProperty(_libtess.gluEnum.GLU_TESS_BOUNDARY_ONLY, boundaryOnly);\n      this.gluTessProperty(_libtess.gluEnum.GLU_TESS_WINDING_RULE, opts.windingRule);\n\n      this.start(polygons, holes);\n\n      return this._out;\n    }\n  }, {\n    key: '_begin',\n    value: function _begin(type) {\n      this._primitiveType = type;\n      this._current = [];\n    }\n  }, {\n    key: '_end_fan',\n    value: function _end_fan() {\n      var c = this._current.shift(),\n          p1 = this._current.shift();\n      while (this._current.length) {\n        var p2 = this._current.shift();\n        this._out.push(c, p1, p2);\n        p1 = p2;\n      }\n    }\n  }, {\n    key: '_end_strip',\n    value: function _end_strip() {\n      var p1 = this._current.shift(),\n          p2 = this._current.shift();\n      while (this._current.length) {\n        var p3 = this._current.shift();\n        this._out.push(p1, p2, p3);\n        p1 = p2;\n        p2 = p3;\n      }\n    }\n  }, {\n    key: '_end',\n    value: function _end() {\n      switch (this._primitiveType) {\n        case GL_TRIANGLE_FAN:\n          this._end_fan();\n          break;\n        case GL_TRIANGLE_STRIP:\n          this._end_strip();\n          break;\n        case GL_TRIANGLES:\n        case GL_LINE_LOOP:\n        default:\n          this._out.push(this._current);\n          break;\n      }\n    }\n  }, {\n    key: '_vertex',\n    value: function _vertex(v) {\n      this._current.push(v);\n    }\n  }, {\n    key: '_edge',\n    value: function _edge() {}\n  }, {\n    key: '_error',\n    value: function _error(errno) {\n      console.error('error number: ' + errno);\n    }\n  }, {\n    key: '_combine',\n    value: function _combine(v, data, w) {\n      for (var i = 0; i < 4; ++i) {\n        if (!data[i]) {\n          data[i] = new Array(this._vsize);\n          for (var j = 0; j < this._vsize; ++j) {\n            data[i][j] = 0;\n          }\n        }\n      }\n      var r = new Array(this._vsize);\n      for (var _i = 0; _i < this._vsize; ++_i) {\n        r[_i] = data[0][_i] * w[0] + data[1][_i] * w[1] + data[2][_i] * w[2] + data[3][_i] * w[3];\n      }\n      return r;\n    }\n  }]);\n\n  return Tesselator;\n}(_libtess.GluTesselator);\n\n/**\n * Helper for triangulate\n * @private\n */\n\n\nfunction to_triangles(data) {\n  var result = [];\n  for (var i = 0; i < data.length; i += 3) {\n    result.push([data[i], data[i + 1], data[i + 2]]);\n  }\n  return result;\n}\n\n/**\n * Runs the tesselator\n * @see http://www.glprogramming.com/red/chapter11.html\n *\n * @param {TesselatorOptions} [options=TesselatorOptions] Options\n *\n * @returns {Array}\n */\nfunction run() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_OPTIONS;\n\n  var tesselator = new Tesselator(options.vertexSize),\n      result = tesselator.run(options);\n  return options.boundaryOnly ? result : result.map(to_triangles);\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tesselator = exports.polygon = undefined;\n\nvar _tesselator = require('./tesselator');\n\nvar tess = _interopRequireWildcard(_tesselator);\n\nvar _polygon = require('./polygon');\n\nvar p = _interopRequireWildcard(_polygon);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar polygon = exports.polygon = p;\nvar tesselator = exports.tesselator = tess;\n\nif (typeof window !== 'undefined') {\n  window.PolygonTools = {\n    polygon: p,\n    tesselator: tess,\n    version: window.polygon_tools_version || '',\n    build: window.polygon_tools_rev || ''\n  };\n}","/**\n * Offset edge of the polygon\n *\n * @param  {Object} current\n * @param  {Object} next\n * @constructor\n */\nfunction Edge(current, next) {\n\n  /**\n   * @type {Object}\n   */\n  this.current = current;\n\n  /**\n   * @type {Object}\n   */\n  this.next = next;\n\n  /**\n   * @type {Object}\n   */\n  this._inNormal  = this.inwardsNormal();\n\n  /**\n   * @type {Object}\n   */\n  this._outNormal = this.outwardsNormal();\n}\n\n/**\n * Creates outwards normal\n * @return {Object}\n */\nEdge.prototype.outwardsNormal = function() {\n  var inwards = this.inwardsNormal();\n  return [\n    -inwards[0],\n    -inwards[1]\n  ];\n};\n\n/**\n * Creates inwards normal\n * @return {Object}\n */\nEdge.prototype.inwardsNormal = function() {\n  var dx = this.next[0] - this.current[0],\n      dy = this.next[1] - this.current[1],\n      edgeLength = Math.sqrt(dx * dx + dy * dy);\n\n  if (edgeLength === 0) throw new Error('Vertices overlap');\n\n  return [\n    -dy / edgeLength,\n     dx / edgeLength\n  ];\n};\n\n/**\n * Offsets the edge by dx, dy\n * @param  {Number} dx\n * @param  {Number} dy\n * @return {Edge}\n */\nEdge.prototype.offset = function(dx, dy) {\n  return Edge.offsetEdge(this.current, this.next, dx, dy);\n};\n\n\n/**\n * @param  {Number} dx\n * @param  {Number} dy\n * @return {Edge}\n */\nEdge.prototype.inverseOffset = function(dx, dy) {\n  return Edge.offsetEdge(this.next, this.current, dx, dy);\n};\n\n\n/**\n * @static\n * @param  {Array.<Number>} current\n * @param  {Array.<Number>} next\n * @param  {Number}         dx\n * @param  {Number}         dy\n * @return {Edge}\n */\nEdge.offsetEdge = function(current, next, dx, dy) {\n  return new Edge([\n    current[0] + dx,\n    current[1] + dy\n  ], [\n    next[0] + dx,\n    next[1] + dy\n  ]);\n};\n\n\n/**\n *\n * @return {Edge}\n */\nEdge.prototype.inverse = function () {\n  return new Edge(this.next, this.current);\n};\n\n\nmodule.exports = Edge;\n","module.exports = { \n  NORMAL:               0, \n  NON_CONTRIBUTING:     1, \n  SAME_TRANSITION:      2, \n  DIFFERENT_TRANSITION: 3\n};\n","'use strict';\n\nmodule.exports = TinyQueue;\nmodule.exports.default = TinyQueue;\n\nfunction TinyQueue(data, compare) {\n    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);\n\n    this.data = data || [];\n    this.length = this.data.length;\n    this.compare = compare || defaultCompare;\n\n    if (this.length > 0) {\n        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nTinyQueue.prototype = {\n\n    push: function (item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    },\n\n    pop: function () {\n        if (this.length === 0) return undefined;\n\n        var top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    },\n\n    peek: function () {\n        return this.data[0];\n    },\n\n    _up: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var item = data[pos];\n\n        while (pos > 0) {\n            var parent = (pos - 1) >> 1;\n            var current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    },\n\n    _down: function (pos) {\n        var data = this.data;\n        var compare = this.compare;\n        var halfLength = this.length >> 1;\n        var item = data[pos];\n\n        while (pos < halfLength) {\n            var left = (pos << 1) + 1;\n            var right = left + 1;\n            var best = data[left];\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n};\n","\nfunction TreeBase() {}\n\n// removes all nodes from the tree\nTreeBase.prototype.clear = function() {\n    this._root = null;\n    this.size = 0;\n};\n\n// returns node data if found, null otherwise\nTreeBase.prototype.find = function(data) {\n    var res = this._root;\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            return res.data;\n        }\n        else {\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// returns iterator to node if found, null otherwise\nTreeBase.prototype.findIter = function(data) {\n    var res = this._root;\n    var iter = this.iterator();\n\n    while(res !== null) {\n        var c = this._comparator(data, res.data);\n        if(c === 0) {\n            iter._cursor = res;\n            return iter;\n        }\n        else {\n            iter._ancestors.push(res);\n            res = res.get_child(c > 0);\n        }\n    }\n\n    return null;\n};\n\n// Returns an iterator to the tree node at or immediately after the item\nTreeBase.prototype.lowerBound = function(item) {\n    var cur = this._root;\n    var iter = this.iterator();\n    var cmp = this._comparator;\n\n    while(cur !== null) {\n        var c = cmp(item, cur.data);\n        if(c === 0) {\n            iter._cursor = cur;\n            return iter;\n        }\n        iter._ancestors.push(cur);\n        cur = cur.get_child(c > 0);\n    }\n\n    for(var i=iter._ancestors.length - 1; i >= 0; --i) {\n        cur = iter._ancestors[i];\n        if(cmp(item, cur.data) < 0) {\n            iter._cursor = cur;\n            iter._ancestors.length = i;\n            return iter;\n        }\n    }\n\n    iter._ancestors.length = 0;\n    return iter;\n};\n\n// Returns an iterator to the tree node immediately after the item\nTreeBase.prototype.upperBound = function(item) {\n    var iter = this.lowerBound(item);\n    var cmp = this._comparator;\n\n    while(iter.data() !== null && cmp(iter.data(), item) === 0) {\n        iter.next();\n    }\n\n    return iter;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.min = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.left !== null) {\n        res = res.left;\n    }\n\n    return res.data;\n};\n\n// returns null if tree is empty\nTreeBase.prototype.max = function() {\n    var res = this._root;\n    if(res === null) {\n        return null;\n    }\n\n    while(res.right !== null) {\n        res = res.right;\n    }\n\n    return res.data;\n};\n\n// returns a null iterator\n// call next() or prev() to point to an element\nTreeBase.prototype.iterator = function() {\n    return new Iterator(this);\n};\n\n// calls cb on each node's data, in order\nTreeBase.prototype.each = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.next()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n// calls cb on each node's data, in reverse order\nTreeBase.prototype.reach = function(cb) {\n    var it=this.iterator(), data;\n    while((data = it.prev()) !== null) {\n        if(cb(data) === false) {\n            return;\n        }\n    }\n};\n\n\nfunction Iterator(tree) {\n    this._tree = tree;\n    this._ancestors = [];\n    this._cursor = null;\n}\n\nIterator.prototype.data = function() {\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns first node\n// otherwise, returns next node\nIterator.prototype.next = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._minNode(root);\n        }\n    }\n    else {\n        if(this._cursor.right === null) {\n            // no greater node in subtree, go up to parent\n            // if coming from a right child, continue up the stack\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.right === save);\n        }\n        else {\n            // get the next node from the subtree\n            this._ancestors.push(this._cursor);\n            this._minNode(this._cursor.right);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\n// if null-iterator, returns last node\n// otherwise, returns previous node\nIterator.prototype.prev = function() {\n    if(this._cursor === null) {\n        var root = this._tree._root;\n        if(root !== null) {\n            this._maxNode(root);\n        }\n    }\n    else {\n        if(this._cursor.left === null) {\n            var save;\n            do {\n                save = this._cursor;\n                if(this._ancestors.length) {\n                    this._cursor = this._ancestors.pop();\n                }\n                else {\n                    this._cursor = null;\n                    break;\n                }\n            } while(this._cursor.left === save);\n        }\n        else {\n            this._ancestors.push(this._cursor);\n            this._maxNode(this._cursor.left);\n        }\n    }\n    return this._cursor !== null ? this._cursor.data : null;\n};\n\nIterator.prototype._minNode = function(start) {\n    while(start.left !== null) {\n        this._ancestors.push(start);\n        start = start.left;\n    }\n    this._cursor = start;\n};\n\nIterator.prototype._maxNode = function(start) {\n    while(start.right !== null) {\n        this._ancestors.push(start);\n        start = start.right;\n    }\n    this._cursor = start;\n};\n\nmodule.exports = TreeBase;\n\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n    this.red = true;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction RBTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nRBTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nRBTree.prototype.insert = function(data) {\n    var ret = false;\n\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        ret = true;\n        this.size++;\n    }\n    else {\n        var head = new Node(undefined); // fake tree root\n\n        var dir = 0;\n        var last = 0;\n\n        // setup\n        var gp = null; // grandparent\n        var ggp = head; // grand-grand-parent\n        var p = null; // parent\n        var node = this._root;\n        ggp.right = this._root;\n\n        // search down\n        while(true) {\n            if(node === null) {\n                // insert new node at the bottom\n                node = new Node(data);\n                p.set_child(dir, node);\n                ret = true;\n                this.size++;\n            }\n            else if(is_red(node.left) && is_red(node.right)) {\n                // color flip\n                node.red = true;\n                node.left.red = false;\n                node.right.red = false;\n            }\n\n            // fix red violation\n            if(is_red(node) && is_red(p)) {\n                var dir2 = ggp.right === gp;\n\n                if(node === p.get_child(last)) {\n                    ggp.set_child(dir2, single_rotate(gp, !last));\n                }\n                else {\n                    ggp.set_child(dir2, double_rotate(gp, !last));\n                }\n            }\n\n            var cmp = this._comparator(node.data, data);\n\n            // stop if found\n            if(cmp === 0) {\n                break;\n            }\n\n            last = dir;\n            dir = cmp < 0;\n\n            // update helpers\n            if(gp !== null) {\n                ggp = gp;\n            }\n            gp = p;\n            p = node;\n            node = node.get_child(dir);\n        }\n\n        // update root\n        this._root = head.right;\n    }\n\n    // make root black\n    this._root.red = false;\n\n    return ret;\n};\n\n// returns true if removed, false if not found\nRBTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var gp = null; // grand parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        var last = dir;\n\n        // update helpers\n        gp = p;\n        p = node;\n        node = node.get_child(dir);\n\n        var cmp = this._comparator(data, node.data);\n\n        dir = cmp > 0;\n\n        // save found node\n        if(cmp === 0) {\n            found = node;\n        }\n\n        // push the red node down\n        if(!is_red(node) && !is_red(node.get_child(dir))) {\n            if(is_red(node.get_child(!dir))) {\n                var sr = single_rotate(node, dir);\n                p.set_child(last, sr);\n                p = sr;\n            }\n            else if(!is_red(node.get_child(!dir))) {\n                var sibling = p.get_child(!last);\n                if(sibling !== null) {\n                    if(!is_red(sibling.get_child(!last)) && !is_red(sibling.get_child(last))) {\n                        // color flip\n                        p.red = false;\n                        sibling.red = true;\n                        node.red = true;\n                    }\n                    else {\n                        var dir2 = gp.right === p;\n\n                        if(is_red(sibling.get_child(last))) {\n                            gp.set_child(dir2, double_rotate(p, last));\n                        }\n                        else if(is_red(sibling.get_child(!last))) {\n                            gp.set_child(dir2, single_rotate(p, last));\n                        }\n\n                        // ensure correct coloring\n                        var gpc = gp.get_child(dir2);\n                        gpc.red = true;\n                        node.red = true;\n                        gpc.left.red = false;\n                        gpc.right.red = false;\n                    }\n                }\n            }\n        }\n    }\n\n    // replace and remove if found\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n        this.size--;\n    }\n\n    // update root and make it black\n    this._root = head.right;\n    if(this._root !== null) {\n        this._root.red = false;\n    }\n\n    return found !== null;\n};\n\nfunction is_red(node) {\n    return node !== null && node.red;\n}\n\nfunction single_rotate(root, dir) {\n    var save = root.get_child(!dir);\n\n    root.set_child(!dir, save.get_child(dir));\n    save.set_child(dir, root);\n\n    root.red = true;\n    save.red = false;\n\n    return save;\n}\n\nfunction double_rotate(root, dir) {\n    root.set_child(!dir, single_rotate(root.get_child(!dir), !dir));\n    return single_rotate(root, dir);\n}\n\nmodule.exports = RBTree;\n","\nvar TreeBase = require('./treebase');\n\nfunction Node(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n}\n\nNode.prototype.get_child = function(dir) {\n    return dir ? this.right : this.left;\n};\n\nNode.prototype.set_child = function(dir, val) {\n    if(dir) {\n        this.right = val;\n    }\n    else {\n        this.left = val;\n    }\n};\n\nfunction BinTree(comparator) {\n    this._root = null;\n    this._comparator = comparator;\n    this.size = 0;\n}\n\nBinTree.prototype = new TreeBase();\n\n// returns true if inserted, false if duplicate\nBinTree.prototype.insert = function(data) {\n    if(this._root === null) {\n        // empty tree\n        this._root = new Node(data);\n        this.size++;\n        return true;\n    }\n\n    var dir = 0;\n\n    // setup\n    var p = null; // parent\n    var node = this._root;\n\n    // search down\n    while(true) {\n        if(node === null) {\n            // insert new node at the bottom\n            node = new Node(data);\n            p.set_child(dir, node);\n            ret = true;\n            this.size++;\n            return true;\n        }\n\n        // stop if found\n        if(this._comparator(node.data, data) === 0) {\n            return false;\n        }\n\n        dir = this._comparator(node.data, data) < 0;\n\n        // update helpers\n        p = node;\n        node = node.get_child(dir);\n    }\n};\n\n// returns true if removed, false if not found\nBinTree.prototype.remove = function(data) {\n    if(this._root === null) {\n        return false;\n    }\n\n    var head = new Node(undefined); // fake tree root\n    var node = head;\n    node.right = this._root;\n    var p = null; // parent\n    var found = null; // found item\n    var dir = 1;\n\n    while(node.get_child(dir) !== null) {\n        p = node;\n        node = node.get_child(dir);\n        var cmp = this._comparator(data, node.data);\n        dir = cmp > 0;\n\n        if(cmp === 0) {\n            found = node;\n        }\n    }\n\n    if(found !== null) {\n        found.data = node.data;\n        p.set_child(p.right === node, node.get_child(node.left === null));\n\n        this._root = head.right;\n        this.size--;\n        return true;\n    }\n    else {\n        return false;\n    }\n};\n\nmodule.exports = BinTree;\n\n","module.exports = {\n    RBTree: require('./lib/rbtree'),\n    BinTree: require('./lib/bintree')\n};\n","/**\n * Signed area of the triangle (p0, p1, p2)\n * @param  {Array.<Number>} p0\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Number}\n */\nmodule.exports = function signedArea(p0, p1, p2) {\n  return (p0[0] - p2[0]) * (p1[1] - p2[1]) - (p1[0] - p2[0]) * (p0[1] - p2[1]);\n};\n","var signedArea = require('./signed_area');\nvar EdgeType   = require('./edge_type');\n\n\n/**\n * Sweepline event\n *\n * @param {Array.<Number>}  point\n * @param {Boolean}         left\n * @param {SweepEvent=}     otherEvent\n * @param {Boolean}         isSubject\n * @param {Number}          edgeType\n */\nfunction SweepEvent(point, left, otherEvent, isSubject, edgeType) {\n\n  /**\n   * Is left endpoint?\n   * @type {Boolean}\n   */\n  this.left = left;\n\n  /**\n   * @type {Array.<Number>}\n   */\n  this.point = point;\n\n  /**\n   * Other edge reference\n   * @type {SweepEvent}\n   */\n  this.otherEvent = otherEvent;\n\n  /**\n   * Belongs to source or clipping polygon\n   * @type {Boolean}\n   */\n  this.isSubject = isSubject;\n\n  /**\n   * Edge contribution type\n   * @type {Number}\n   */\n  this.type = edgeType || EdgeType.NORMAL;\n\n\n  /**\n   * In-out transition for the sweepline crossing polygon\n   * @type {Boolean}\n   */\n  this.inOut = false;\n\n\n  /**\n   * @type {Boolean}\n   */\n  this.otherInOut = false;\n\n  /**\n   * Previous event in result?\n   * @type {SweepEvent}\n   */\n  this.prevInResult = null;\n\n  /**\n   * Does event belong to result?\n   * @type {Boolean}\n   */\n  this.inResult = false;\n\n\n  // connection step\n\n  /**\n   * @type {Boolean}\n   */\n  this.resultInOut = false;\n}\n\n\nSweepEvent.prototype = {\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isBelow: function(p) {\n    return this.left ?\n      signedArea (this.point, this.otherEvent.point, p) > 0 :\n      signedArea (this.otherEvent.point, this.point, p) > 0;\n  },\n\n\n  /**\n   * @param  {Array.<Number>}  p\n   * @return {Boolean}\n   */\n  isAbove: function(p) {\n    return !this.isBelow(p);\n  },\n\n\n  /**\n   * @return {Boolean}\n   */\n  isVertical: function() {\n    return this.point[0] === this.otherEvent.point[0];\n  }\n};\n\nmodule.exports = SweepEvent;\n","var signedArea = require('./signed_area');\n// var equals = require('./equals');\n\n/**\n * @param  {SweepEvent} e1\n * @param  {SweepEvent} e2\n * @return {Number}\n */\nmodule.exports = function sweepEventsComp(e1, e2) {\n  var p1 = e1.point;\n  var p2 = e2.point;\n\n  // Different x-coordinate\n  if (p1[0] > p2[0]) return 1;\n  if (p1[0] < p2[0]) return -1;\n\n  // Different points, but same x-coordinate\n  // Event with lower y-coordinate is processed first\n  if (p1[1] !== p2[1]) return p1[1] > p2[1] ? 1 : -1;\n\n  return specialCases(e1, e2, p1, p2);\n};\n\n\nfunction specialCases(e1, e2, p1, p2) {\n  // Same coordinates, but one is a left endpoint and the other is\n  // a right endpoint. The right endpoint is processed first\n  if (e1.left !== e2.left)\n    return e1.left ? 1 : -1;\n\n  // Same coordinates, both events\n  // are left endpoints or right endpoints.\n  // not collinear\n  if (signedArea (p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {\n    // the event associate to the bottom segment is processed first\n    return (!e1.isBelow(e2.otherEvent.point)) ? 1 : -1;\n  }\n\n  // uncomment this if you want to play with multipolygons\n  // if (e1.isSubject === e2.isSubject) {\n  //   if(equals(e1.point, e2.point) && e1.contourId === e2.contourId) {\n  //     return 0;\n  //   } else {\n  //     return e1.contourId > e2.contourId ? 1 : -1;\n  //   }\n  // }\n\n  return (!e1.isSubject && e2.isSubject) ? 1 : -1;\n}\n","module.exports = function equals(p1, p2) {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n};","var signedArea    = require('./signed_area');\nvar compareEvents = require('./compare_events');\nvar equals        = require('./equals');\n\n\n/**\n * @param  {SweepEvent} le1\n * @param  {SweepEvent} le2\n * @return {Number}\n */\nmodule.exports = function compareSegments(le1, le2) {\n  if (le1 === le2) return 0;\n\n  // Segments are not collinear\n  if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 ||\n    signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {\n\n    // If they share their left endpoint use the right endpoint to sort\n    if (equals(le1.point, le2.point)) return le1.isBelow(le2.otherEvent.point) ? -1 : 1;\n\n    // Different left endpoint: use the left endpoint to sort\n    if (le1.point[0] === le2.point[0]) return le1.point[1] < le2.point[1] ? -1 : 1;\n\n    // has the line segment associated to e1 been inserted\n    // into S after the line segment associated to e2 ?\n    if (compareEvents(le1, le2) === 1) return le2.isAbove(le1.point) ? -1 : 1;\n\n    // The line segment associated to e2 has been inserted\n    // into S after the line segment associated to e1\n    return le1.isBelow(le2.point) ? -1 : 1;\n  }\n\n  if (le1.isSubject === le2.isSubject) { // same polygon\n    if (equals(le1.point, le2.point)) {\n      if (equals(le1.otherEvent.point, le2.otherEvent.point)) {\n        return 0;\n      } else {\n        return le1.contourId > le2.contourId ? 1 : -1;\n      }\n    }\n  } else { // Segments are collinear, but belong to separate polygons\n    return le1.isSubject ? -1 : 1;\n  }\n\n  return compareEvents(le1, le2) === 1 ? 1 : -1;\n};\n","var EPSILON = 1e-9;\n\n/**\n * Finds the magnitude of the cross product of two vectors (if we pretend\n * they're in three dimensions)\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The magnitude of the cross product\n */\nfunction krossProduct(a, b) {\n  return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Finds the dot product of two vectors.\n *\n * @param {Object} a First vector\n * @param {Object} b Second vector\n * @private\n * @returns {Number} The dot product\n */\nfunction dotProduct(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Finds the intersection (if any) between two line segments a and b, given the\n * line segments' end points a1, a2 and b1, b2.\n *\n * This algorithm is based on Schneider and Eberly.\n * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf\n * Page 244.\n *\n * @param {Array.<Number>} a1 point of first line\n * @param {Array.<Number>} a2 point of first line\n * @param {Array.<Number>} b1 point of second line\n * @param {Array.<Number>} b2 point of second line\n * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints\n *                                         (meaning connected segments) as\n *                                         intersections\n * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of\n * intersection. If they overlap, the two end points of the overlapping segment.\n * Otherwise, null.\n */\nmodule.exports = function(a1, a2, b1, b2, noEndpointTouch) {\n  // The algorithm expects our lines in the form P + sd, where P is a point,\n  // s is on the interval [0, 1], and d is a vector.\n  // We are passed two points. P can be the first point of each pair. The\n  // vector, then, could be thought of as the distance (in x and y components)\n  // from the first point to the second point.\n  // So first, let's make our vectors:\n  var va = [a2[0] - a1[0], a2[1] - a1[1]];\n  var vb = [b2[0] - b1[0], b2[1] - b1[1]];\n  // We also define a function to convert back to regular point form:\n\n  /* eslint-disable arrow-body-style */\n\n  function toPoint(p, s, d) {\n    return [\n      p[0] + s * d[0],\n      p[1] + s * d[1]\n    ];\n  }\n\n  /* eslint-enable arrow-body-style */\n\n  // The rest is pretty much a straight port of the algorithm.\n  var e = [b1[0] - a1[0], b1[1] - a1[1]];\n  var kross = krossProduct(va, vb);\n  var sqrKross = kross * kross;\n  var sqrLenA = dotProduct(va, va);\n  var sqrLenB = dotProduct(vb, vb);\n\n  // Check for line intersection. This works because of the properties of the\n  // cross product -- specifically, two vectors are parallel if and only if the\n  // cross product is the 0 vector. The full calculation involves relative error\n  // to account for possible very small line segments. See Schneider & Eberly\n  // for details.\n  if (sqrKross > EPSILON * sqrLenA * sqrLenB) {\n    // If they're not parallel, then (because these are line segments) they\n    // still might not actually intersect. This code checks that the\n    // intersection point of the lines is actually on both line segments.\n    var s = krossProduct(e, vb) / kross;\n    if (s < 0 || s > 1) {\n      // not on line segment a\n      return null;\n    }\n    var t = krossProduct(e, va) / kross;\n    if (t < 0 || t > 1) {\n      // not on line segment b\n      return null;\n    }\n    return noEndpointTouch ? null : [toPoint(a1, s, va)];\n  }\n\n  // If we've reached this point, then the lines are either parallel or the\n  // same, but the segments could overlap partially or fully, or not at all.\n  // So we need to find the overlap, if any. To do that, we can use e, which is\n  // the (vector) difference between the two initial points. If this is parallel\n  // with the line itself, then the two lines are the same line, and there will\n  // be overlap.\n  var sqrLenE = dotProduct(e, e);\n  kross = krossProduct(e, va);\n  sqrKross = kross * kross;\n\n  if (sqrKross > EPSILON * sqrLenA * sqrLenE) {\n    // Lines are just parallel, not the same. No overlap.\n    return null;\n  }\n\n  var sa = dotProduct(va, e) / sqrLenA;\n  var sb = sa + dotProduct(va, vb) / sqrLenA;\n  var smin = Math.min(sa, sb);\n  var smax = Math.max(sa, sb);\n\n  // this is, essentially, the FindIntersection acting on floats from\n  // Schneider & Eberly, just inlined into this function.\n  if (smin <= 1 && smax >= 0) {\n\n    // overlap on an end point\n    if (smin === 1) {\n      return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];\n    }\n\n    if (smax === 0) {\n      return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];\n    }\n\n    if (noEndpointTouch && smin === 0 && smax === 1) return null;\n\n    // There's overlap on a segment -- two points of intersection. Return both.\n    return [\n      toPoint(a1, smin > 0 ? smin : 0, va),\n      toPoint(a1, smax < 1 ? smax : 1, va),\n    ];\n  }\n\n  return null;\n};\n","var INTERSECTION    = 0;\nvar UNION           = 1;\nvar DIFFERENCE      = 2;\nvar XOR             = 3;\n\nvar EMPTY           = [];\n\nvar edgeType        = require('./edge_type');\n\nvar Queue           = require('tinyqueue');\nvar Tree            = require('bintrees').RBTree;\nvar SweepEvent      = require('./sweep_event');\n\nvar compareEvents   = require('./compare_events');\nvar compareSegments = require('./compare_segments');\nvar intersection    = require('./segment_intersection');\nvar equals          = require('./equals');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// global.Tree = Tree;\n// global.compareSegments = compareSegments;\n// global.SweepEvent = SweepEvent;\n// global.signedArea = require('./signed_area');\n\n/**\n * @param  {<Array.<Number>} s1\n * @param  {<Array.<Number>} s2\n * @param  {Boolean}         isSubject\n * @param  {Queue}           eventQueue\n * @param  {Array.<Number>}  bbox\n */\nfunction processSegment(s1, s2, isSubject, depth, eventQueue, bbox) {\n  // Possible degenerate condition.\n  // if (equals(s1, s2)) return;\n\n  var e1 = new SweepEvent(s1, false, undefined, isSubject);\n  var e2 = new SweepEvent(s2, false, e1,        isSubject);\n  e1.otherEvent = e2;\n\n  e1.contourId = e2.contourId = depth;\n\n  if (compareEvents(e1, e2) > 0) {\n    e2.left = true;\n  } else {\n    e1.left = true;\n  }\n\n  bbox[0] = min(bbox[0], s1[0]);\n  bbox[1] = min(bbox[1], s1[1]);\n  bbox[2] = max(bbox[2], s1[0]);\n  bbox[3] = max(bbox[3], s1[1]);\n\n  // Pushing it so the queue is sorted from left to right,\n  // with object on the left having the highest priority.\n  eventQueue.push(e1);\n  eventQueue.push(e2);\n}\n\nvar contourId = 0;\n\nfunction processPolygon(polygon, isSubject, depth, queue, bbox) {\n  var i, len;\n  if (typeof polygon[0][0] === 'number') {\n    for (i = 0, len = polygon.length - 1; i < len; i++) {\n      processSegment(polygon[i], polygon[i + 1], isSubject, depth + 1, queue, bbox);\n    }\n  } else {\n    for (i = 0, len = polygon.length; i < len; i++) {\n      contourId++;\n      processPolygon(polygon[i], isSubject, contourId, queue, bbox);\n    }\n  }\n}\n\n\nfunction fillQueue(subject, clipping, sbbox, cbbox) {\n  var eventQueue = new Queue(null, compareEvents);\n  contourId = 0;\n\n  processPolygon(subject,  true,  0, eventQueue, sbbox);\n  processPolygon(clipping, false, 0, eventQueue, cbbox);\n\n  return eventQueue;\n}\n\n\nfunction computeFields(event, prev, sweepLine, operation) {\n  // compute inOut and otherInOut fields\n  if (prev === null) {\n    event.inOut      = false;\n    event.otherInOut = true;\n\n  // previous line segment in sweepline belongs to the same polygon\n  } else if (event.isSubject === prev.isSubject) {\n    event.inOut      = !prev.inOut;\n    event.otherInOut = prev.otherInOut;\n\n  // previous line segment in sweepline belongs to the clipping polygon\n  } else {\n    event.inOut      = !prev.otherInOut;\n    event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;\n  }\n\n  // compute prevInResult field\n  if (prev) {\n    event.prevInResult = (!inResult(prev, operation) || prev.isVertical()) ?\n       prev.prevInResult : prev;\n  }\n  // check if the line segment belongs to the Boolean operation\n  event.inResult = inResult(event, operation);\n}\n\n\nfunction inResult(event, operation) {\n  switch (event.type) {\n    case edgeType.NORMAL:\n      switch (operation) {\n        case INTERSECTION:\n          return !event.otherInOut;\n        case UNION:\n          return event.otherInOut;\n        case DIFFERENCE:\n          return (event.isSubject && event.otherInOut) ||\n                 (!event.isSubject && !event.otherInOut);\n        case XOR:\n          return true;\n      }\n    case edgeType.SAME_TRANSITION:\n      return operation === INTERSECTION || operation === UNION;\n    case edgeType.DIFFERENT_TRANSITION:\n      return operation === DIFFERENCE;\n    case edgeType.NON_CONTRIBUTING:\n      return false;\n  }\n  return false;\n}\n\n\n/**\n * @param  {SweepEvent} se1\n * @param  {SweepEvent} se2\n * @param  {Queue}      queue\n * @return {Number}\n */\nfunction possibleIntersection(se1, se2, queue) {\n  // that disallows self-intersecting polygons,\n  // did cost us half a day, so I'll leave it\n  // out of respect\n  // if (se1.isSubject === se2.isSubject) return;\n\n  var inter = intersection(\n    se1.point, se1.otherEvent.point,\n    se2.point, se2.otherEvent.point\n  );\n\n  var nintersections = inter ? inter.length : 0;\n  if (nintersections === 0) return 0; // no intersection\n\n  // the line segments intersect at an endpoint of both line segments\n  if ((nintersections === 1) &&\n      (equals(se1.point, se2.point) ||\n       equals(se1.otherEvent.point, se2.otherEvent.point))) {\n    return 0;\n  }\n\n  if (nintersections === 2 && se1.isSubject === se2.isSubject){\n    if(se1.contourId === se2.contourId){\n    console.warn('Edges of the same polygon overlap',\n      se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);\n    }\n    //throw new Error('Edges of the same polygon overlap');\n    return 0;\n  }\n\n  // The line segments associated to se1 and se2 intersect\n  if (nintersections === 1) {\n\n    // if the intersection point is not an endpoint of se1\n    if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {\n      divideSegment(se1, inter[0], queue);\n    }\n\n    // if the intersection point is not an endpoint of se2\n    if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {\n      divideSegment(se2, inter[0], queue);\n    }\n    return 1;\n  }\n\n  // The line segments associated to se1 and se2 overlap\n  var events        = [];\n  var leftCoincide  = false;\n  var rightCoincide = false;\n\n  if (equals(se1.point, se2.point)) {\n    leftCoincide = true; // linked\n  } else if (compareEvents(se1, se2) === 1) {\n    events.push(se2, se1);\n  } else {\n    events.push(se1, se2);\n  }\n\n  if (equals(se1.otherEvent.point, se2.otherEvent.point)) {\n    rightCoincide = true;\n  } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {\n    events.push(se2.otherEvent, se1.otherEvent);\n  } else {\n    events.push(se1.otherEvent, se2.otherEvent);\n  }\n\n  if ((leftCoincide && rightCoincide) || leftCoincide) {\n    // both line segments are equal or share the left endpoint\n    se1.type = edgeType.NON_CONTRIBUTING;\n    se2.type = (se1.inOut === se2.inOut) ?\n      edgeType.SAME_TRANSITION :\n      edgeType.DIFFERENT_TRANSITION;\n\n    if (leftCoincide && !rightCoincide) {\n      // honestly no idea, but changing events selection from [2, 1]\n      // to [0, 1] fixes the overlapping self-intersecting polygons issue\n      divideSegment(events[0].otherEvent, events[1].point, queue);\n    }\n    return 2;\n  }\n\n  // the line segments share the right endpoint\n  if (rightCoincide) {\n    divideSegment(events[0], events[1].point, queue);\n    return 3;\n  }\n\n  // no line segment includes totally the other one\n  if (events[0] !== events[3].otherEvent) {\n    divideSegment(events[0], events[1].point, queue);\n    divideSegment(events[1], events[2].point, queue);\n    return 3;\n  }\n\n  // one line segment includes the other one\n  divideSegment(events[0], events[1].point, queue);\n  divideSegment(events[3].otherEvent, events[2].point, queue);\n\n  return 3;\n}\n\n\n/**\n * @param  {SweepEvent} se\n * @param  {Array.<Number>} p\n * @param  {Queue} queue\n * @return {Queue}\n */\nfunction divideSegment(se, p, queue)  {\n  var r = new SweepEvent(p, false, se,            se.isSubject);\n  var l = new SweepEvent(p, true,  se.otherEvent, se.isSubject);\n\n  if (equals(se.point, se.otherEvent.point)) {\n    console.warn('what is that?', se);\n  }\n\n  r.contourId = l.contourId = se.contourId;\n\n  // avoid a rounding error. The left event would be processed after the right event\n  if (compareEvents(l, se.otherEvent) > 0) {\n    se.otherEvent.left = true;\n    l.left = false;\n  }\n\n  // avoid a rounding error. The left event would be processed after the right event\n  // if (compareEvents(se, r) > 0) {}\n\n  se.otherEvent.otherEvent = l;\n  se.otherEvent = r;\n\n  queue.push(l);\n  queue.push(r);\n\n  return queue;\n}\n\n\n/* eslint-disable no-unused-vars, no-debugger */\nfunction iteratorEquals(it1, it2) {\n  return it1._cursor === it2._cursor;\n}\n\n\nfunction _renderSweepLine(sweepLine, pos, event) {\n  var map = window.map;\n  if (!map) return;\n  if (window.sws) window.sws.forEach(function(p) {\n    map.removeLayer(p);\n  });\n  window.sws = [];\n  sweepLine.each(function(e) {\n    var poly = L.polyline([e.point.slice().reverse(), e.otherEvent.point.slice().reverse()], { color: 'green' }).addTo(map);\n    window.sws.push(poly);\n  });\n\n  if (window.vt) map.removeLayer(window.vt);\n  var v = pos.slice();\n  var b = map.getBounds();\n  window.vt = L.polyline([[b.getNorth(), v[0]], [b.getSouth(), v[0]]], {color: 'green', weight: 1}).addTo(map);\n\n  if (window.ps) map.removeLayer(window.ps);\n  window.ps = L.polyline([event.point.slice().reverse(), event.otherEvent.point.slice().reverse()], {color: 'black', weight: 9, opacity: 0.4}).addTo(map);\n  debugger;\n}\n/* eslint-enable no-unused-vars, no-debugger */\n\n\nfunction subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation) {\n  var sortedEvents = [];\n  var prev, next;\n\n  var sweepLine = new Tree(compareSegments);\n  var sortedEvents = [];\n\n  var rightbound = min(sbbox[2], cbbox[2]);\n\n  var prev, next;\n\n  while (eventQueue.length) {\n    var event = eventQueue.pop();\n    sortedEvents.push(event);\n\n    // optimization by bboxes for intersection and difference goes here\n    if ((operation === INTERSECTION && event.point[0] > rightbound) ||\n        (operation === DIFFERENCE   && event.point[0] > sbbox[2])) {\n      break;\n    }\n\n    if (event.left) {\n      sweepLine.insert(event);\n      // _renderSweepLine(sweepLine, event.point, event);\n\n      next = sweepLine.findIter(event);\n      prev = sweepLine.findIter(event);\n      event.iterator = sweepLine.findIter(event);\n\n      // Cannot get out of the tree what we just put there\n      if (!prev || !next) {\n        console.log('brute');\n        var iterators = findIterBrute(sweepLine);\n        prev = iterators[0];\n        next = iterators[1];\n      }\n\n      if (prev.data() !== sweepLine.min()) {\n        prev.prev();\n      } else {\n        prev = sweepLine.iterator(); //findIter(sweepLine.max());\n        prev.prev();\n        prev.next();\n      }\n      next.next();\n\n      computeFields(event, prev.data(), sweepLine, operation);\n\n      if (next.data()) {\n        if (possibleIntersection(event, next.data(), eventQueue) === 2) {\n          computeFields(event, prev.data(), sweepLine, operation);\n          computeFields(event, next.data(), sweepLine, operation);\n        }\n      }\n\n      if (prev.data()) {\n        if (possibleIntersection(prev.data(), event, eventQueue) === 2) {\n          var prevprev = sweepLine.findIter(prev.data());\n          if (prevprev.data() !== sweepLine.min()) {\n            prevprev.prev();\n          } else {\n            prevprev = sweepLine.findIter(sweepLine.max());\n            prevprev.next();\n          }\n          computeFields(prev.data(), prevprev.data(), sweepLine, operation);\n          computeFields(event, prev.data(), sweepLine, operation);\n        }\n      }\n    } else {\n      event = event.otherEvent;\n      next = sweepLine.findIter(event);\n      prev = sweepLine.findIter(event);\n\n      // _renderSweepLine(sweepLine, event.otherEvent.point, event);\n\n      if (!(prev && next)) continue;\n\n      if (prev.data() !== sweepLine.min()) {\n        prev.prev();\n      } else {\n        prev = sweepLine.iterator();\n        prev.prev(); // sweepLine.findIter(sweepLine.max());\n        prev.next();\n      }\n      next.next();\n      sweepLine.remove(event);\n\n      //_renderSweepLine(sweepLine, event.otherEvent.point, event);\n\n      if (next.data() && prev.data()) {\n        possibleIntersection(prev.data(), next.data(), eventQueue);\n      }\n    }\n  }\n  return sortedEvents;\n}\n\nfunction findIterBrute(sweepLine, q) {\n  var prev = sweepLine.iterator();\n  var next = sweepLine.iterator();\n  var it   = sweepLine.iterator(), data;\n  while((data = it.next()) !== null) {\n    prev.next();\n    next.next();\n    if (data === event) {\n      break;\n    }\n  }\n  return [prev, next];\n}\n\n\nfunction swap (arr, i, n) {\n  var temp = arr[i];\n  arr[i] = arr[n];\n  arr[n] = temp;\n}\n\n\nfunction changeOrientation(contour) {\n  return contour.reverse();\n}\n\n\nfunction isArray (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n}\n\n\nfunction addHole(contour, idx) {\n  if (isArray(contour[0]) && !isArray(contour[0][0])) {\n    contour = [contour];\n  }\n  contour[idx] = [];\n  return contour;\n}\n\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<SweepEvent>}\n */\nfunction orderEvents(sortedEvents) {\n  var event, i, len;\n  var resultEvents = [];\n  for (i = 0, len = sortedEvents.length; i < len; i++) {\n    event = sortedEvents[i];\n    if ((event.left && event.inResult) ||\n      (!event.left && event.otherEvent.inResult)) {\n      resultEvents.push(event);\n    }\n  }\n\n  // Due to overlapping edges the resultEvents array can be not wholly sorted\n  var sorted = false;\n  while (!sorted) {\n    sorted = true;\n    for (i = 0, len = resultEvents.length; i < len; i++) {\n      if ((i + 1) < len &&\n        compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {\n        swap(resultEvents, i, i + 1);\n        sorted = false;\n      }\n    }\n  }\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    resultEvents[i].pos = i;\n  }\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (!resultEvents[i].left) {\n      var temp = resultEvents[i].pos;\n      resultEvents[i].pos = resultEvents[i].otherEvent.pos;\n      resultEvents[i].otherEvent.pos = temp;\n    }\n  }\n\n  return resultEvents;\n}\n\n\n/**\n * @param  {Array.<SweepEvent>} sortedEvents\n * @return {Array.<*>} polygons\n */\nfunction connectEdges(sortedEvents) {\n  var i, len;\n  var resultEvents = orderEvents(sortedEvents);\n\n\n  // \"false\"-filled array\n  var processed = Array(resultEvents.length);\n  var result = [];\n\n  var depth  = [];\n  var holeOf = [];\n  var isHole = {};\n\n  for (i = 0, len = resultEvents.length; i < len; i++) {\n    if (processed[i]) continue;\n\n    var contour = [];\n    result.push(contour);\n\n    var ringId = result.length - 1;\n    depth.push(0);\n    holeOf.push(-1);\n\n\n    if (resultEvents[i].prevInResult) {\n      var lowerContourId = resultEvents[i].prevInResult.contourId;\n      if (!resultEvents[i].prevInResult.resultInOut) {\n        addHole(result[lowerContourId], ringId);\n        holeOf[ringId] = lowerContourId;\n        depth[ringId]  = depth[lowerContourId] + 1;\n        isHole[ringId] = true;\n      } else if (isHole[lowerContourId]) {\n        addHole(result[holeOf[lowerContourId]], ringId);\n        holeOf[ringId] = holeOf[lowerContourId];\n        depth[ringId]  = depth[lowerContourId];\n        isHole[ringId] = true;\n      }\n    }\n\n    var pos = i;\n    var initial = resultEvents[i].point;\n    contour.push(initial);\n\n    while (pos >= i) {\n      processed[pos] = true;\n\n      if (resultEvents[pos].left) {\n        resultEvents[pos].resultInOut = false;\n        resultEvents[pos].contourId   = ringId;\n      } else {\n        resultEvents[pos].otherEvent.resultInOut = true;\n        resultEvents[pos].otherEvent.contourId   = ringId;\n      }\n\n      pos = resultEvents[pos].pos;\n      processed[pos] = true;\n\n      contour.push(resultEvents[pos].point);\n      pos = nextPos(pos, resultEvents, processed);\n    }\n\n    pos = pos === -1 ? i : pos;\n\n    processed[pos] = processed[resultEvents[pos].pos] = true;\n    resultEvents[pos].otherEvent.resultInOut = true;\n    resultEvents[pos].otherEvent.contourId   = ringId;\n\n\n    // depth is even\n    /* eslint-disable no-bitwise */\n    if (depth[ringId] & 1) {\n      changeOrientation(contour);\n    }\n    /* eslint-enable no-bitwise */\n  }\n\n  return result;\n}\n\n\n/**\n * @param  {Number} pos\n * @param  {Array.<SweepEvent>} resultEvents\n * @param  {Array.<Boolean>}    processed\n * @return {Number}\n */\nfunction nextPos(pos, resultEvents, processed) {\n  var newPos = pos + 1;\n  var length = resultEvents.length;\n  while (newPos < length &&\n         equals(resultEvents[newPos].point, resultEvents[pos].point)) {\n    if (!processed[newPos]) {\n      return newPos;\n    } else {\n      newPos = newPos + 1;\n    }\n  }\n\n  newPos = pos - 1;\n\n  while (processed[newPos]) {\n    newPos = newPos - 1;\n  }\n  return newPos;\n}\n\n\nfunction trivialOperation(subject, clipping, operation) {\n  var result = null;\n  if (subject.length * clipping.length === 0) {\n    if (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION || operation === XOR) {\n      result = (subject.length === 0) ? clipping : subject;\n    }\n  }\n  return result;\n}\n\n\nfunction compareBBoxes(subject, clipping, sbbox, cbbox, operation) {\n  var result = null;\n  if (sbbox[0] > cbbox[2] ||\n      cbbox[0] > sbbox[2] ||\n      sbbox[1] > cbbox[3] ||\n      cbbox[1] > sbbox[3]) {\n    if (operation === INTERSECTION) {\n      result = EMPTY;\n    } else if (operation === DIFFERENCE) {\n      result = subject;\n    } else if (operation === UNION || operation === XOR) {\n      result = subject.concat(clipping);\n    }\n  }\n  return result;\n}\n\n\nfunction boolean(subject, clipping, operation) {\n  var trivial = trivialOperation(subject, clipping, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  var sbbox = [Infinity, Infinity, -Infinity, -Infinity];\n  var cbbox = [Infinity, Infinity, -Infinity, -Infinity];\n\n  var eventQueue = fillQueue(subject, clipping, sbbox, cbbox);\n\n  trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);\n  if (trivial) {\n    return trivial === EMPTY ? null : trivial;\n  }\n  var sortedEvents = subdivideSegments(eventQueue, subject, clipping, sbbox, cbbox, operation);\n  return connectEdges(sortedEvents);\n}\n\n\nmodule.exports = boolean;\n\n\nmodule.exports.union = function(subject, clipping) {\n  return boolean(subject, clipping, UNION);\n};\n\n\nmodule.exports.diff = function(subject, clipping) {\n  return boolean(subject, clipping, DIFFERENCE);\n};\n\n\nmodule.exports.xor = function(subject, clipping) {\n  return boolean(subject, clipping, XOR);\n};\n\n\nmodule.exports.intersection = function(subject, clipping) {\n  return boolean(subject, clipping, INTERSECTION);\n};\n\n\n/**\n * @enum {Number}\n */\nmodule.exports.operations = {\n  INTERSECTION: INTERSECTION,\n  DIFFERENCE:   DIFFERENCE,\n  UNION:        UNION,\n  XOR:          XOR\n};\n\n\n// for testing\nmodule.exports.fillQueue            = fillQueue;\nmodule.exports.computeFields        = computeFields;\nmodule.exports.subdivideSegments    = subdivideSegments;\nmodule.exports.divideSegment        = divideSegment;\nmodule.exports.possibleIntersection = possibleIntersection;\n","module.exports = require('./src/index');\n","/**\n * @param  {*} arr\n * @return {Boolean}\n */\nvar isArray = module.exports.isArray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\n\n\n/**\n * @param  {Array.<Number>} p1\n * @param  {Array.<Number>} p2\n * @return {Boolean}\n */\nmodule.exports.equals = function equals(p1, p2) {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n};\n\n\n/**\n * @param  {*}       coordinates\n * @param  {Number=} depth\n * @return {*}\n */\nmodule.exports.orientRings = function orientRings(coordinates, depth, isHole) {\n  depth = depth || 0;\n  var i, len;\n  if (isArray(coordinates) && typeof coordinates[0][0] === 'number') {\n    var area = 0;\n    var ring = coordinates;\n\n    for (i = 0, len = ring.length; i < len; i++) {\n      var pt1 = ring[i];\n      var pt2 = ring[(i + 1) % len];\n      area += pt1[0] * pt2[1];\n      area -= pt2[0] * pt1[1];\n    }\n    if ((!isHole && area > 0) || (isHole && area < 0)) {\n      ring.reverse();\n    }\n  } else {\n    for (i = 0, len = coordinates.length; i < len; i++) {\n      orientRings(coordinates[i], depth + 1, i > 0);\n    }\n  }\n\n  return coordinates;\n};","var Edge     = require('./edge');\nvar martinez = require('martinez-polygon-clipping');\nvar utils    = require('./utils');\n\n\nvar isArray     = utils.isArray;\nvar equals      = utils.equals;\nvar orientRings = utils.orientRings;\n\n\n/**\n * Offset builder\n *\n * @param {Array.<Object>=} vertices\n * @param {Number=}        arcSegments\n * @constructor\n */\nfunction Offset(vertices, arcSegments) {\n\n  /**\n   * @type {Array.<Object>}\n   */\n  this.vertices = null;\n\n  /**\n   * @type {Array.<Edge>}\n   */\n  this.edges = null;\n\n  /**\n   * @type {Boolean}\n   */\n  this._closed = false;\n\n\n  /**\n   * @type {Number}\n   */\n  this._distance = 0;\n\n  if (vertices) {\n    this.data(vertices);\n  }\n\n  /**\n   * Segments in edge bounding arches\n   * @type {Number}\n   */\n  this._arcSegments = arcSegments !== undefined ? arcSegments : 5;\n}\n\n/**\n * Change data set\n * @param  {Array.<Array>} vertices\n * @return {Offset}\n */\nOffset.prototype.data = function(vertices) {\n  this._edges = [];\n  if (!isArray (vertices)) {\n    throw new Error('Offset requires at least one coodinate to work with');\n  }\n\n  if (isArray(vertices) && typeof vertices[0] === 'number') {\n    this.vertices = vertices;\n  } else {\n    this.vertices = orientRings(vertices);\n    this._processContour(this.vertices, this._edges);\n  }\n\n  return this;\n};\n\n\n/**\n * Recursively process contour to create normals\n * @param  {*} contour\n * @param  {Array} edges\n */\nOffset.prototype._processContour = function(contour, edges) {\n  var i, len;\n  if (isArray(contour[0]) && typeof contour[0][0] === 'number') {\n    len = contour.length;\n    if (equals(contour[0], contour[len - 1])) {\n      len -= 1; // otherwise we get division by zero in normals\n    }\n    for (i = 0; i < len; i++) {\n      edges.push(new Edge(contour[i], contour[(i + 1) % len]));\n    }\n  } else {\n    for (i = 0, len = contour.length; i < len; i++) {\n      edges.push([]);\n      this._processContour(contour[i], edges[edges.length - 1]);\n    }\n  }\n};\n\n\n/**\n * @param  {Number} arcSegments\n * @return {Offset}\n */\nOffset.prototype.arcSegments = function(arcSegments) {\n  this._arcSegments = arcSegments;\n  return this;\n};\n\n\n/**\n * Validates if the first and last points repeat\n * TODO: check CCW\n *\n * @param  {Array.<Object>} vertices\n */\nOffset.prototype.validate = function(vertices) {\n  var len = vertices.length;\n  if (typeof vertices[0] === 'number') return [vertices];\n  if (vertices[0][0] === vertices[len - 1][0] &&\n    vertices[0][1] === vertices[len - 1][1]) {\n    if (len > 1) {\n      vertices = vertices.slice(0, len - 1);\n      this._closed = true;\n    }\n  }\n  return vertices;\n};\n\n\n/**\n * Creates arch between two edges\n *\n * @param  {Array.<Object>} vertices\n * @param  {Object}         center\n * @param  {Number}         radius\n * @param  {Object}         startVertex\n * @param  {Object}         endVertex\n * @param  {Number}         segments\n * @param  {Boolean}        outwards\n */\nOffset.prototype.createArc = function(vertices, center, radius, startVertex,\n    endVertex, segments, outwards) {\n\n  var PI2 = Math.PI * 2,\n      startAngle = Math.atan2(startVertex[1] - center[1], startVertex[0] - center[0]),\n      endAngle   = Math.atan2(endVertex[1] - center[1], endVertex[0] - center[0]);\n\n  // odd number please\n  if (segments % 2 === 0) {\n    segments -= 1;\n  }\n\n  if (startAngle < 0) {\n    startAngle += PI2;\n  }\n\n  if (endAngle < 0) {\n    endAngle += PI2;\n  }\n\n  var angle = ((startAngle > endAngle) ?\n               (startAngle - endAngle) :\n               (startAngle + PI2 - endAngle)),\n      segmentAngle = ((outwards) ? -angle : PI2 - angle) / segments;\n\n  vertices.push(startVertex);\n  for (var i = 1; i < segments; ++i) {\n    angle = startAngle + segmentAngle * i;\n    vertices.push([\n      center[0] + Math.cos(angle) * radius,\n      center[1] + Math.sin(angle) * radius\n    ]);\n  }\n  vertices.push(endVertex);\n  return vertices;\n};\n\n\n/**\n * @param  {Number}  dist\n * @param  {String=} units\n * @return {Offset}\n */\nOffset.prototype.distance = function(dist, units) {\n  this._distance = dist || 0;\n  return this;\n};\n\n\n/**\n * @static\n * @param  {Number}  degrees\n * @param  {String=} units\n * @return {Number}\n */\nOffset.degreesToUnits = function(degrees, units) {\n  switch (units) {\n    case 'miles':\n      degrees = degrees / 69.047;\n    break;\n    case 'feet':\n      degrees = degrees / 364568.0;\n      break;\n    case 'kilometers':\n      degrees = degrees / 111.12;\n      break;\n    case 'meters':\n    case 'metres':\n      degrees = degrees / 111120.0;\n      break;\n    case 'degrees':\n    case 'pixels':\n    default:\n      break;\n  }\n  return degrees;\n};\n\n\n/**\n * @param  {Array.<Object>} vertices\n * @return {Array.<Object>}\n */\nOffset.prototype.ensureLastPoint = function(vertices) {\n  if (!equals(vertices[0], vertices[vertices.length - 1])) {\n    vertices.push([\n      vertices[0][0],\n      vertices[0][1]\n    ]);\n  }\n  return vertices;\n};\n\n\n/**\n * Decides by the sign if it's a padding or a margin\n *\n * @param  {Number} dist\n * @return {Array.<Object>}\n */\nOffset.prototype.offset = function(dist) {\n  this.distance(dist);\n  return this._distance === 0 ? this.vertices :\n      (this._distance > 0 ? this.margin(this._distance) :\n        this.padding(-this._distance));\n};\n\n\n/**\n * @param  {Array.<Array.<Number>>} vertices\n * @param  {Array.<Number>}         pt1\n * @param  {Array.<Number>}         pt2\n * @param  {Number}                 dist\n * @return {Array.<Array.<Number>>}\n */\nOffset.prototype._offsetSegment = function(v1, v2, e1, dist) {\n  var vertices = [];\n  var offsets = [\n    e1.offset(e1._inNormal[0] * dist, e1._inNormal[1] * dist),\n    e1.inverseOffset(e1._outNormal[0] * dist, e1._outNormal[1] * dist)\n  ];\n\n  for (var i = 0, len = 2; i < len; i++) {\n    var thisEdge = offsets[i],\n        prevEdge = offsets[(i + len - 1) % len];\n    this.createArc(\n              vertices,\n              i === 0 ? v1 : v2, // edges[i].current, // p1 or p2\n              dist,\n              prevEdge.next,\n              thisEdge.current,\n              this._arcSegments,\n              true\n            );\n  }\n\n  return vertices;\n};\n\n\n/**\n * @param  {Number} dist\n * @return {Array.<Number>}\n */\nOffset.prototype.margin = function(dist) {\n  this.distance(dist);\n\n  if (typeof this.vertices[0] === 'number') { // point\n    return this.offsetPoint(this._distance);\n  }\n\n  if (dist === 0) return this.vertices;\n\n  var union = this.offsetLines(this._distance);\n  //return union;\n  union = martinez.union(this.vertices, union);\n  return orientRings(union);\n};\n\n\n/**\n * @param  {Number} dist\n * @return {Array.<Number>}\n */\nOffset.prototype.padding = function(dist) {\n  this.distance(dist);\n\n  if (this._distance === 0) return this.ensureLastPoint(this.vertices);\n  if (this.vertices.length === 2 && typeof this.vertices[0] === 'number') {\n    return this.vertices;\n  }\n\n  var union = this.offsetLines(this._distance);\n  var diff = martinez.diff(this.vertices, union);\n  return orientRings(diff);\n};\n\n\n/**\n * Creates margin polygon\n * @param  {Number} dist\n * @return {Array.<Object>}\n */\nOffset.prototype.offsetLine = function(dist) {\n  if (dist === 0) return this.vertices;\n  return orientRings(this.offsetLines(dist));\n};\n\n\n/**\n * Just offsets lines, no fill\n * @param  {Number} dist\n * @return {Array.<Array.<Array.<Number>>>}\n */\nOffset.prototype.offsetLines = function(dist) {\n  if (dist < 0) throw new Error('Cannot apply negative margin to the line');\n  var union;\n  this.distance(dist);\n  if (isArray(this.vertices[0]) && typeof this.vertices[0][0] !== 'number') {\n    for (var i = 0, len = this._edges.length; i < len; i++) {\n      union = (i === 0) ?\n        this.offsetContour(this.vertices[i], this._edges[i]):\n        martinez.union(union, this.offsetContour(this.vertices[i], this._edges[i]));\n    }\n  } else {\n    union = (this.vertices.length === 1) ?\n      this.offsetPoint() :\n      this.offsetContour(this.vertices, this._edges);\n  }\n\n  return union;\n};\n\n\n/**\n * @param  {Array.<Array.<Number>>|Array.<Array.<...>>} curve\n * @param  {Array.<Edge>|Array.<Array.<...>>} edges\n * @return {Polygon}\n */\nOffset.prototype.offsetContour = function(curve, edges) {\n  var union, i, len;\n  if (isArray(curve[0]) && typeof curve[0][0] === 'number') {\n    // we have 1 less edge than vertices\n    for (i = 0, len = curve.length - 1; i < len; i++) {\n      var segment = this.ensureLastPoint(\n        this._offsetSegment(curve[i], curve[i + 1], edges[i], this._distance)\n      );\n      union = (i === 0) ?\n                [this.ensureLastPoint(segment)] :\n                martinez.union(union, this.ensureLastPoint(segment));\n    }\n  } else {\n    for (i = 0, len = edges.length; i < len; i++) {\n      union = (i === 0) ?\n        this.offsetContour(curve[i], edges[i]) :\n        martinez.union(union, this.offsetContour(curve[i], edges[i]));\n    }\n  }\n  return union;\n};\n\n\n/**\n * @param  {Number} distance\n * @return {Array.<Array.<Number>}\n */\nOffset.prototype.offsetPoint = function(distance) {\n  this.distance(distance);\n  var vertices = this._arcSegments * 2;\n  var points   = [];\n  var center   = this.vertices;\n  var radius   = this._distance;\n  var angle    = 0;\n\n  if (vertices % 2 === 0) vertices++;\n\n  for (var i = 0; i < vertices; i++) {\n    angle += (2 * Math.PI / vertices); // counter-clockwise\n    points.push([\n      center[0] + (radius * Math.cos(angle)),\n      center[1] + (radius * Math.sin(angle))\n    ]);\n  }\n\n  return orientRings([this.ensureLastPoint(points)]);\n};\n\n\nOffset.orientRings = orientRings;\n\nmodule.exports = Offset;\n","const { polygon } = require(\"polygon-tools\")\nconst Offset = require(\"polygon-offset\")\n\nfunction getPolygonFromUDTRegions(regions, classification) {\n  const udtPolygons = regions\n    .map((r) => {\n      switch (r.regionType || r.type) {\n        case \"polygon\":\n          if (r.points.length < 3) return null\n          return r\n        case \"bounding-box\":\n          return {\n            regionType: \"polygon\",\n            classification: r.classification,\n            points: [\n              { x: r.centerX - r.width / 2, y: r.centerY - r.height / 2 },\n              { x: r.centerX + r.width / 2, y: r.centerY - r.height / 2 },\n              { x: r.centerX + r.width / 2, y: r.centerY + r.height / 2 },\n              { x: r.centerX - r.width / 2, y: r.centerY + r.height / 2 },\n            ],\n          }\n        default:\n          return null\n      }\n    })\n    .filter(Boolean)\n\n  const polys = udtPolygons.map((p) => p.points.map(({ x, y }) => [x, y]))\n\n  const firstPolyIndex = udtPolygons.findIndex(\n    (p) => p.classification === classification\n  )\n  if (firstPolyIndex === -1) return []\n  let outputPoly = [polys[firstPolyIndex]]\n\n  for (let i = 1; i < polys.length; i++) {\n    const poly = polys[i]\n    if (udtPolygons[i].classification === classification) {\n      outputPoly = polygon.union(...outputPoly, poly)\n    } else {\n      // outputPoly = polygon.subtract(outputPoly, poly)\n      outputPoly = outputPoly.flatMap((innerPoly) => {\n        return polygon.subtract(innerPoly, poly)\n      })\n    }\n  }\n\n  return outputPoly\n}\n\nfunction sumArea(polygons) {\n  return polygons.map(polygon.area).reduce((acc, area) => acc + area, 0)\n}\n\nfunction inflate(polygons, amount) {\n  return polygons.flatMap((polygon) => {\n    const offset = new Offset()\n    return offset.data(polygon).margin(amount)\n  })\n}\n\nfunction getUnionAndIntersection(p1, p2) {\n  const fullArea = [\n    [0, 0],\n    [1, 0],\n    [1, 1],\n    [0, 1],\n  ]\n\n  const fullAreaMinusP1 = polygon.subtract(fullArea, ...p1)\n  const fullAreaMinusP2 = polygon.subtract(fullArea, ...p2)\n  const fullAreaMinusP1P2 = polygon.subtract(fullArea, ...p1, ...p2)\n\n  const p1Area = 1 - sumArea(fullAreaMinusP1)\n  const p2Area = 1 - sumArea(fullAreaMinusP2)\n  const unionArea = 1 - sumArea(fullAreaMinusP1P2)\n  const intersectionArea = p1Area + p2Area - unionArea\n  return { unionArea, intersectionArea }\n}\n\n// Public Method, Takes UDT Regions and returns I/O\nfunction getIOU(ann1, ann2, { borderMargin = 0 } = {}) {\n  const classifications = Array.from(\n    new Set([\n      ...ann1.map((s) => s.classification),\n      ...ann2.map((s) => s.classification),\n    ])\n  )\n\n  let totalUnionArea = 0\n  let totalIntersectionArea = 0\n\n  for (const classification of classifications) {\n    const p1 = getPolygonFromUDTRegions(ann1, classification)\n    const p2 = getPolygonFromUDTRegions(ann2, classification)\n\n    const { unionArea, intersectionArea } = getUnionAndIntersection(p1, p2)\n\n    if (borderMargin === 0) {\n      totalUnionArea += unionArea\n      totalIntersectionArea += intersectionArea\n      continue\n    }\n\n    const p1Inflated = inflate(p1, borderMargin)\n    const p2Inflated = inflate(p2, borderMargin)\n\n    const { intersectionArea: infA } = getUnionAndIntersection(p1Inflated, p2)\n    const { intersectionArea: infB } = getUnionAndIntersection(p1, p2Inflated)\n\n    const infIntersection = infA + infB - intersectionArea\n\n    return infIntersection / unionArea\n  }\n\n  // console.log({ totalUnionArea, totalIntersectionArea })\n  if (totalUnionArea <= 0.0001) return 1\n\n  return totalIntersectionArea / totalUnionArea\n}\n\nmodule.exports = {\n  getIOU,\n  getPolygonFromUDTRegions,\n}\n"]}